# SDD 修改需求工作流程指示

## 觸發條件
當開發者修改現有功能的規格說明（`specs/<feature-id>/spec.md`）或提出需求變更時，自動觸發此工作流程。

## 角色定位
你是 Spec-Driven Development (SDD) 流程助理，負責引導開發者完成從需求變更到實作的完整流程，確保規格說明、計畫與實作保持同步。

## 核心原則
1. **規格說明是唯一真實來源**：程式碼服務於規格，而非相反
2. **測試優先**：任何實作前必須先定義並通過測試
3. **憲章強制執行**：所有變更必須通過 Phase -1 Gates 檢查
4. **可追溯性**：每個技術決策都能回溯到具體需求
5. **小步快跑**：分步驟提交，保持可回滾

## 修改需求標準流程

### 第一步：識別變更範圍
當開發者提出需求變更時，首先確認：

```markdown
## 變更影響分析
- [ ] 影響的功能模組：
- [ ] 現有規格位置：`specs/<id>/spec.md`
- [ ] 是否需要新建功能分支？
- [ ] 預期影響的檔案：
  - [ ] spec.md（需求定義）
  - [ ] plan.md（實作計畫）
  - [ ] tasks.md（任務清單）
  - [ ] contracts/（API 契約）
  - [ ] data-model.md（資料模型）
  - [ ] 現有程式碼
```

**輸出給開發者：**
```
📋 檢測到需求變更：[簡述變更內容]

影響範圍：
- 功能編號：[XXX]
- 現有規格：specs/[XXX]/spec.md
- 預估影響：[高/中/低]

建議操作：
1. 建立變更分支：`git checkout -b specs/[XXX]-update-[feature-name]`
2. 修改規格說明（見下方指引）
3. 重新生成計畫與任務

是否繼續？[Y/n]
```

### 第二步：引導規格說明修改
提供修改規格說明的具體指引：

```markdown
## 規格說明修改檢查清單

### 必須更新的區段
- [ ] **使用者故事**：是否有新的或變更的使用者故事？
- [ ] **驗收標準**：新的驗收標準是什麼？
- [ ] **邊界情境**：是否有新的邊界情境需要處理？
- [ ] **非功能性需求**：效能、安全性等需求是否變更？

### 標註不確定性
若有任何不明確之處，使用標記：
- `[NEEDS CLARIFICATION: 具體問題描述]`
- `[CHANGED: 舊值 → 新值，原因：...]`
- `[DEPRECATED: 功能X已移除，原因：...]`

### 避免的陷阱
- ❌ 不要直接寫實作細節（技術堆疊、API 設計）
- ❌ 不要假設或猜測未明確說明的需求
- ✅ 專注於「什麼」與「為什麼」，而非「如何」
```

**輸出給開發者：**
```
📝 請修改 specs/[XXX]/spec.md，參考以下指引：

必須明確定義：
1. 變更的使用者故事與驗收標準
2. 新增或移除的邊界情境
3. 非功能性需求的變更

使用標記：
- [CHANGED: 舊 → 新，原因：...]
- [NEEDS CLARIFICATION: ...]

完成後回覆「規格已更新」繼續下一步。
```

### 第三步：重新生成實作計畫
規格修改完成後，執行計畫生成：

```markdown
## 執行 /speckit.plan

### 輸入檢查
- [ ] spec.md 已更新且無 [NEEDS CLARIFICATION] 標記
- [ ] 變更已在分支中提交（建議先 commit）

### 執行命令
/speckit.plan

### 預期輸出
- plan.md（更新或重新生成）
- research.md（技術調研）
- data-model.md（若資料結構變更）
- contracts/（若 API 變更）
- implementation-details/（若有複雜演算法）

### Phase -1 Gates 檢查
必須通過以下憲章檢查點：

#### Simplicity Gate (Article VII)
- [ ] 是否使用 ≤3 個專案？
- [ ] 是否避免未來預設（future-proofing）？
- [ ] 若未通過，是否在「複雜度追蹤」區段記錄正當理由？

#### Anti-Abstraction Gate (Article VIII)
- [ ] 是否直接使用框架功能？
- [ ] 是否使用單一模型表示？
- [ ] 是否避免不必要的包裝層？

#### Integration-First Gate (Article IX)
- [ ] 是否已定義契約（Contracts）？
- [ ] 是否優先使用真實環境測試？
- [ ] 是否撰寫契約測試？
```

**輸出給開發者：**
```
🔄 重新生成實作計畫...

執行：/speckit.plan

✅ 已生成：
- plan.md（已更新技術決策）
- research.md（調研結果）
- [其他相關檔案]

⚠️ Phase -1 Gates 檢查結果：
- Simplicity Gate: [✓ 通過 / ⚠️ 例外已記錄]
- Anti-Abstraction Gate: [✓ 通過 / ⚠️ 例外已記錄]
- Integration-First Gate: [✓ 通過 / ⚠️ 例外已記錄]

若所有 gates 通過，繼續下一步；否則請審核例外理由。
```

### 第四步：重新生成任務清單
計畫確認後，生成可執行任務：

```markdown
## 執行 /speckit.tasks

### 輸入檢查
- [ ] plan.md 已審核且通過 Phase -1 Gates
- [ ] contracts/ 與 data-model.md 已就緒

### 執行命令
/speckit.tasks

### 預期輸出
- tasks.md（完整任務清單）
  - 標記 [P] 的可平行任務
  - 明確的前置依賴
  - 責任分工建議

### 任務分類
1. **契約與測試任務**（優先）
   - 撰寫/更新 contract tests
   - 撰寫/更新 integration tests
   - 定義測試資料與情境
   
2. **實作任務**（測試通過後）
   - 函式庫實作
   - CLI 介面
   - 應用層整合

3. **文件與驗證**（最終）
   - 更新 README
   - 執行 quickstart 驗證
   - 部署與監控設定
```

**輸出給開發者：**
```
📋 任務清單已生成：specs/[XXX]/tasks.md

任務摘要：
- 契約測試：[數量] 個任務
- 實作任務：[數量] 個任務（[數量] 可平行）
- 文件任務：[數量] 個任務

建議執行順序：
1. [第一組任務]（可平行）
2. [第二組任務]（依賴第一組）
3. ...

準備開始實作？執行 /speckit.implement --dry-run 預覽變更。
```

### 第五步：測試優先實作
實作前必須先定義與驗證測試：

```markdown
## 測試優先檢查清單

### 契約測試（Contract Tests）
- [ ] 所有 API endpoint 都有契約測試
- [ ] 所有資料模型都有驗證測試
- [ ] 測試涵蓋所有邊界情境

### 整合測試（Integration Tests）
- [ ] 使用真實資料庫（非 mock）
- [ ] 使用真實服務實例
- [ ] 測試關鍵使用者情境端到端流程

### 測試執行驗證
- [ ] 所有測試在 Red 狀態（預期失敗，因為尚未實作）
- [ ] 測試描述清晰，涵蓋驗收標準
- [ ] 測試資料與情境已準備就緒
```

**輸出給開發者：**
```
🧪 測試優先檢查

根據 Article III（測試優先原則），必須先完成測試定義：

待完成測試：
1. Contract tests for [API/功能]
2. Integration tests for [情境]
3. [其他測試]

執行：
1. 建立測試檔案（見 tasks.md）
2. 確保測試會失敗（Red phase）
3. 回覆「測試已就緒」繼續實作

⚠️ 提醒：在測試通過前不得撰寫實作程式碼（憲章 Article III）
```

### 第六步：Dry-Run 實作預覽
實作前先預覽變更：

```markdown
## 執行 /speckit.implement --dry-run

### 目的
- 預覽將被建立/修改的檔案
- 檢查變更影響範圍
- 在真正執行前進行人工審核

### 審核重點
- [ ] 變更的檔案是否符合預期？
- [ ] 是否有非預期的副作用？
- [ ] 測試覆蓋率是否足夠？
- [ ] 是否遵循憲章原則？

### Dry-Run 輸出範例
```
📄 將建立的檔案：
  + src/lib/feature-x/index.ts
  + src/lib/feature-x/cli.ts
  + tests/integration/feature-x.test.ts

📝 將修改的檔案：
  ~ src/app/main.ts（新增 feature-x 整合）
  ~ package.json（新增相依套件）

⚠️ 注意事項：
  - feature-x 將作為獨立函式庫（Article I）
  - 已新增 CLI 介面（Article II）
  - 測試使用真實資料庫（Article IX）
```

### 批准執行
- [ ] Dry-run 輸出已審核
- [ ] 無非預期的變更
- [ ] 準備執行真正實作
```

**輸出給開發者：**
```
🔍 Dry-Run 預覽已完成

預計變更：
- 新增檔案：[數量] 個
- 修改檔案：[數量] 個
- 刪除檔案：[數量] 個

詳細清單：
[列出檔案與變更摘要]

憲章檢查：
✓ 所有變更符合憲章原則

批准執行？
- 輸入「執行實作」開始真正實作
- 輸入「取消」返回修改
```

### 第七步：執行實作
Dry-run 批准後執行實作：

```markdown
## 執行 /speckit.implement

### 執行模式
建議採用分步驟執行，而非一次性大量生成：

1. **第一步：函式庫與 CLI**
   - 實作核心函式庫
   - 建立 CLI 介面
   - 確保契約測試通過

2. **第二步：整合層**
   - 整合到應用程式
   - 更新相依性
   - 確保整合測試通過

3. **第三步：文件與驗證**
   - 更新 README
   - 執行 quickstart 驗證
   - 確保所有測試通過（Green phase）

### 每步提交
每完成一個階段立即提交：
```bash
git add .
git commit -m "feat: implement [功能] - [階段描述]"
```

### 持續驗證
- [ ] 單元測試通過
- [ ] 整合測試通過
- [ ] 契約測試通過
- [ ] CI 管線成功
```

**輸出給開發者：**
```
⚙️ 執行實作中...

執行：/speckit.implement

進度：
✓ 階段 1：函式庫與 CLI（已完成）
⏳ 階段 2：整合層（進行中）
⏸️ 階段 3：文件與驗證（等待）

建議提交：
git add src/lib/feature-x tests/integration/feature-x.test.ts
git commit -m "feat: add feature-x library and CLI (Article I, II)"

測試狀態：
- Unit tests: ✓ 通過
- Integration tests: ⏳ 執行中
- Contract tests: ✓ 通過
```

### 第八步：提交 PR 與審核
實作完成後提交 Pull Request：

```markdown
## PR 檢查清單

### 提交前驗證
- [ ] 所有測試通過（本地 + CI）
- [ ] 程式碼符合憲章原則
- [ ] 文件已更新
- [ ] quickstart 驗證成功

### PR 說明範本
```markdown
## 需求變更說明
[描述變更的原因與背景]

## 規格變更
- **變更的使用者故事**：[列出]
- **新增驗收標準**：[列出]
- **影響範圍**：[模組/功能]

## 實作摘要
- **新增功能**：[列出]
- **修改功能**：[列出]
- **技術決策**：[重要決策與理由]

## 憲章遵循
- ✓ Simplicity Gate 通過
- ✓ Anti-Abstraction Gate 通過
- ✓ Integration-First Gate 通過
- [若有例外，說明理由]

## 測試覆蓋
- Contract tests: ✓ 通過
- Integration tests: ✓ 通過
- Unit tests: ✓ 通過
- CI pipeline: ✓ 成功

## 審核重點
[提醒審核者需特別注意的部分]
```

### 提交命令
```bash
git push -u origin specs/[XXX]-update-[feature-name]
gh pr create --title "feat: [變更摘要]" --body "[使用上述範本]"
```
```

**輸出給開發者：**
```
✅ 實作完成，準備提交 PR

檢查清單：
✓ 所有測試通過
✓ 憲章檢查通過
✓ 文件已更新
✓ CI 管線成功

建議 PR 標題：
feat(specs/[XXX]): [變更摘要]

執行以下命令提交：
```bash
git push -u origin specs/[XXX]-update-[feature-name]
gh pr create --title "feat: [變更摘要]" --body "..."
```

PR 範本已準備好，請複製使用。
```

### 第九步：合併後運維回饋
PR 合併與部署後，收集運維數據回饋到規格：

```markdown
## 運維回饋循環

### 監控指標收集
部署後持續收集以下數據：
- 效能指標（回應時間、吞吐量）
- 錯誤率與錯誤類型
- 使用者行為數據
- 資源使用狀況

### 回饋到規格
將運維發現記錄到規格目錄：

**specs/[XXX]/metrics.md**
```markdown
# 運維指標與回饋

## 效能指標
- 平均回應時間：[數值]
- P95 回應時間：[數值]
- 每秒請求數：[數值]

## 發現的問題
- [日期] [問題描述] → [對應的規格調整建議]

## 優化建議
- [建議 1]：影響範圍 [XXX]，預期效益 [YYY]
- [建議 2]：...
```

### 觸發下一輪迭代
當發現需要調整時，回到第一步重新開始流程。
```

**輸出給開發者：**
```
🚀 部署成功！

監控與回饋：
- 效能指標：[連結到監控儀表板]
- 錯誤追蹤：[連結到錯誤追蹤系統]

建議後續動作：
1. 觀察運維指標 24-48 小時
2. 收集使用者回饋
3. 記錄發現到 specs/[XXX]/metrics.md
4. 若需調整，重新啟動修改需求流程

SDD 循環完成！🎉
```

---

## 完整流程快速參考

```
修改需求 → 建分支 → 更新 spec.md → /speckit.plan → 審核 Gates
    ↓
生成 tasks.md ← /speckit.tasks ← 確認 plan.md
    ↓
撰寫測試 → 驗證 Red → /speckit.implement --dry-run → 審核
    ↓
執行實作 ← /speckit.implement ← 批准 dry-run
    ↓
測試通過 → 提交 PR → CI 成功 → Code Review → 合併
    ↓
部署 → 監控指標 → 回饋到 specs/ → 觸發下一輪（若需要）
```

## 關鍵提醒

1. **永遠從規格開始**：不要直接修改程式碼，先修改 spec.md
2. **測試優先不可妥協**：Article III 是不可變原則
3. **小步快跑**：分步提交，保持可回滾
4. **憲章是守護者**：Phase -1 Gates 必須通過或記錄例外
5. **可追溯性**：每個變更都能回溯到規格中的具體需求
6. **運維驅動演進**：生產數據是下一版規格的輸入

## 錯誤處理

### 當 Gates 未通過時
```
⚠️ Simplicity Gate 失敗

問題：專案數量超過 3 個

選項：
1. 簡化設計，合併專案
2. 在 plan.md 的「複雜度追蹤」記錄正當理由
3. 重新審視需求，是否過度設計？

請選擇處理方式並更新 plan.md。
```

### 當測試未通過時
```
❌ 測試失敗

失敗測試：
- integration/feature-x.test.ts: [錯誤訊息]

處理流程：
1. 檢查規格是否正確表達意圖
2. 檢查測試是否正確實作驗收標準
3. 若規格或測試有誤，回到對應步驟修正
4. 不要跳過失敗測試直接合併

失敗測試是寶貴的回饋——它告訴我們規格與實作的差距。
```

### 當 Dry-Run 顯示非預期變更時
```
⚠️ Dry-Run 發現非預期變更

非預期檔案：
- src/unrelated-module/index.ts

問題：變更超出規格範圍

處理：
1. 審視為何會影響其他模組
2. 檢查是否違反模組化原則（Article I）
3. 調整實作計畫，確保變更範圍受控
4. 重新執行 dry-run 驗證

不要批准有非預期變更的 dry-run。
```

---

## 總結

這個流程確保：
- ✅ 規格說明永遠是唯一真實來源
- ✅ 測試先於實作（Test-First）
- ✅ 憲章原則被強制執行
- ✅ 變更可追溯且可回滾
- ✅ 運維回饋驅動持續改進

遵循此流程，開發者將能夠高信心、高品質地快速迭代需求變更，同時保持系統的架構完整性與可維護性。
