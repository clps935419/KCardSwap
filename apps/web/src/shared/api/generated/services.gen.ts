// This file is auto-generated by @hey-api/openapi-ts

import type { CancelablePromise } from './core/CancelablePromise';
import { OpenAPI } from './core/OpenAPI';
import { request as __request } from './core/request';
import type { HealthCheckHealthGetResponse, ApiHealthCheckApiV1HealthGetResponse, RootGetResponse, AdminLoginApiV1AuthAdminLoginPostData, AdminLoginApiV1AuthAdminLoginPostResponse, GoogleLoginApiV1AuthGoogleLoginPostData, GoogleLoginApiV1AuthGoogleLoginPostResponse, GoogleCallbackApiV1AuthGoogleCallbackPostData, GoogleCallbackApiV1AuthGoogleCallbackPostResponse, RefreshTokenApiV1AuthRefreshPostData, RefreshTokenApiV1AuthRefreshPostResponse, GetMyProfileApiV1ProfileMeGetResponse, UpdateMyProfileApiV1ProfileMePutData, UpdateMyProfileApiV1ProfileMePutResponse, GetIdolGroupsApiV1IdolsGroupsGetResponse, VerifyReceiptApiV1SubscriptionsVerifyReceiptPostData, VerifyReceiptApiV1SubscriptionsVerifyReceiptPostResponse, GetSubscriptionStatusApiV1SubscriptionsStatusGetResponse, ExpireSubscriptionsApiV1SubscriptionsExpireSubscriptionsPostResponse, BlockUserApiV1FriendsBlockPostData, BlockUserApiV1FriendsBlockPostResponse, UnblockUserApiV1FriendsUnblockPostData, UnblockUserApiV1FriendsUnblockPostResponse, GetMyReportsApiV1ReportsGetResponse, SubmitReportApiV1ReportsPostData, SubmitReportApiV1ReportsPostResponse, GetUploadUrlApiV1CardsUploadUrlPostData, GetUploadUrlApiV1CardsUploadUrlPostResponse, GetMyCardsApiV1CardsMeGetData, GetMyCardsApiV1CardsMeGetResponse, DeleteCardApiV1CardsCardIdDeleteData, DeleteCardApiV1CardsCardIdDeleteResponse, GetQuotaStatusApiV1CardsQuotaStatusGetResponse, ConfirmCardUploadApiV1CardsCardIdConfirmUploadPostData, ConfirmCardUploadApiV1CardsCardIdConfirmUploadPostResponse, GetChatRoomsApiV1ChatsGetResponse, GetMessagesApiV1ChatsRoomIdMessagesGetData, GetMessagesApiV1ChatsRoomIdMessagesGetResponse, SendMessageApiV1ChatsRoomIdMessagesPostData, SendMessageApiV1ChatsRoomIdMessagesPostResponse, MarkMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostData, MarkMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostResponse, CreatePostApiV1PostsPostData, CreatePostApiV1PostsPostResponse, ListPostsApiV1PostsGetData, ListPostsApiV1PostsGetResponse, ClosePostApiV1PostsPostIdClosePostData, ClosePostApiV1PostsPostIdClosePostResponse, ToggleLikeApiV1PostsPostIdLikePostData, ToggleLikeApiV1PostsPostIdLikePostResponse, GetCitiesApiV1LocationsCitiesGetResponse, GetUserGalleryCardsApiV1UsersUserIdGalleryCardsGetData, GetUserGalleryCardsApiV1UsersUserIdGalleryCardsGetResponse, GetMyGalleryCardsApiV1GalleryCardsMeGetResponse, CreateGalleryCardApiV1GalleryCardsPostData, CreateGalleryCardApiV1GalleryCardsPostResponse, DeleteGalleryCardApiV1GalleryCardsCardIdDeleteData, DeleteGalleryCardApiV1GalleryCardsCardIdDeleteResponse, ReorderGalleryCardsApiV1GalleryCardsReorderPutData, ReorderGalleryCardsApiV1GalleryCardsReorderPutResponse, CreateUploadUrlApiV1MediaUploadUrlPostData, CreateUploadUrlApiV1MediaUploadUrlPostResponse, ConfirmUploadApiV1MediaMediaIdConfirmPostData, ConfirmUploadApiV1MediaMediaIdConfirmPostResponse, AttachMediaToPostApiV1MediaPostsPostIdAttachPostData, AttachMediaToPostApiV1MediaPostsPostIdAttachPostResponse, AttachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostData, AttachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostResponse, CreateMessageRequestApiV1MessageRequestsPostData, CreateMessageRequestApiV1MessageRequestsPostResponse, GetMyMessageRequestsApiV1MessageRequestsInboxGetData, GetMyMessageRequestsApiV1MessageRequestsInboxGetResponse, AcceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostData, AcceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostResponse, DeclineMessageRequestApiV1MessageRequestsRequestIdDeclinePostData, DeclineMessageRequestApiV1MessageRequestsRequestIdDeclinePostResponse, GetMyThreadsApiV1ThreadsGetData, GetMyThreadsApiV1ThreadsGetResponse, GetThreadMessagesApiV1ThreadsThreadIdMessagesGetData, GetThreadMessagesApiV1ThreadsThreadIdMessagesGetResponse, SendMessageApiV1ThreadsThreadIdMessagesPostData, SendMessageApiV1ThreadsThreadIdMessagesPostResponse } from './types.gen';

export class DefaultService {
    /**
     * Health Check
     * Health check endpoint for container orchestration.
     * @returns unknown Successful Response
     * @throws ApiError
     */
    public static healthCheckHealthGet(): CancelablePromise<HealthCheckHealthGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/health'
        });
    }
    
    /**
     * Api Health Check
     * API health check endpoint.
     * @returns unknown Successful Response
     * @throws ApiError
     */
    public static apiHealthCheckApiV1HealthGet(): CancelablePromise<ApiHealthCheckApiV1HealthGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/health'
        });
    }
    
    /**
     * Root
     * Root endpoint.
     * @returns unknown Successful Response
     * @throws ApiError
     */
    public static rootGet(): CancelablePromise<RootGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/'
        });
    }
    
}

export class AuthenticationService {
    /**
     * Admin login with email/password
     * Authenticate admin user with email and password and receive JWT tokens
     * @param data The data for the request.
     * @param data.requestBody
     * @returns LoginResponse Successfully authenticated as admin
     * @throws ApiError
     */
    public static adminLoginApiV1AuthAdminLoginPost(data: AdminLoginApiV1AuthAdminLoginPostData): CancelablePromise<AdminLoginApiV1AuthAdminLoginPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/auth/admin-login',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Validation error',
                401: 'Invalid credentials or not an admin',
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Login with Google
     * Authenticate user with Google OAuth token and receive JWT tokens
     * @param data The data for the request.
     * @param data.requestBody
     * @returns LoginResponse Successfully authenticated
     * @throws ApiError
     */
    public static googleLoginApiV1AuthGoogleLoginPost(data: GoogleLoginApiV1AuthGoogleLoginPostData): CancelablePromise<GoogleLoginApiV1AuthGoogleLoginPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/auth/google-login',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Validation error',
                401: 'Invalid Google token',
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Google OAuth Callback with PKCE
     * Authenticate user with Google OAuth authorization code and PKCE code_verifier (Expo AuthSession)
     * @param data The data for the request.
     * @param data.requestBody
     * @returns LoginResponse Successfully authenticated
     * @throws ApiError
     */
    public static googleCallbackApiV1AuthGoogleCallbackPost(data: GoogleCallbackApiV1AuthGoogleCallbackPostData): CancelablePromise<GoogleCallbackApiV1AuthGoogleCallbackPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/auth/google-callback',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Validation error',
                401: 'Invalid authorization code or code_verifier',
                422: 'Token exchange failed'
            }
        });
    }
    
    /**
     * Refresh access token (cookie-based)
     * Use refresh token from httpOnly cookie to obtain new access and refresh tokens
     * @param data The data for the request.
     * @param data.refreshToken
     * @returns RefreshSuccessResponse Successfully refreshed tokens
     * @throws ApiError
     */
    public static refreshTokenApiV1AuthRefreshPost(data: RefreshTokenApiV1AuthRefreshPostData = {}): CancelablePromise<RefreshTokenApiV1AuthRefreshPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/auth/refresh',
            cookies: {
                refresh_token: data.refreshToken
            },
            errors: {
                401: 'Invalid or expired refresh token',
                422: 'Validation Error'
            }
        });
    }
    
}

export class ProfileService {
    /**
     * Get my profile
     * Retrieve the authenticated user's profile information
     * @returns ProfileResponseWrapper Successfully retrieved profile
     * @throws ApiError
     */
    public static getMyProfileApiV1ProfileMeGet(): CancelablePromise<GetMyProfileApiV1ProfileMeGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/profile/me',
            errors: {
                401: 'Unauthorized',
                404: 'Profile not found'
            }
        });
    }
    
    /**
     * Update my profile
     * Update the authenticated user's profile information
     * @param data The data for the request.
     * @param data.requestBody
     * @returns ProfileResponseWrapper Successfully updated profile
     * @throws ApiError
     */
    public static updateMyProfileApiV1ProfileMePut(data: UpdateMyProfileApiV1ProfileMePutData): CancelablePromise<UpdateMyProfileApiV1ProfileMePutResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/api/v1/profile/me',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Validation error',
                401: 'Unauthorized',
                422: 'Validation Error'
            }
        });
    }
    
}

export class IdolsService {
    /**
     * Get all idol groups
     * Get a list of all available K-pop idol groups for onboarding.
     *
     * This endpoint provides the complete list of idol groups that users can select
     * during the onboarding process to indicate their preferences.
     *
     * Each idol group includes:
     * - `id`: Unique identifier (e.g., newjeans, ive, aespa)
     * - `name`: Display name (e.g., NewJeans, IVE, aespa)
     * - `emoji`: Emoji representing the group (e.g., üëñ, ü¶¢, ü¶ã)
     *
     * This is a **public endpoint** that **does not require authentication**.
     * Frontend applications should use this to dynamically populate idol group selection.
     * @returns IdolGroupListResponseWrapper List of all idol groups retrieved successfully
     * @throws ApiError
     */
    public static getIdolGroupsApiV1IdolsGroupsGet(): CancelablePromise<GetIdolGroupsApiV1IdolsGroupsGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/idols/groups'
        });
    }
    
}

export class SubscriptionsService {
    /**
     * Verify Receipt
     * Verify Google Play purchase receipt and update subscription.
     *
     * Features:
     * - Idempotent: Same token + same user returns current status
     * - Token binding: Prevents cross-user replay attacks
     * - Auto-acknowledge: Acknowledges purchase after verification
     *
     * Error codes:
     * - 400_VALIDATION_FAILED: Invalid platform or missing fields
     * - 401_UNAUTHORIZED: Not logged in
     * - 409_CONFLICT: Purchase token already used by another user
     * - 503_SERVICE_UNAVAILABLE: Google Play API unavailable
     * @param data The data for the request.
     * @param data.requestBody
     * @returns SubscriptionStatusResponse Successful Response
     * @throws ApiError
     */
    public static verifyReceiptApiV1SubscriptionsVerifyReceiptPost(data: VerifyReceiptApiV1SubscriptionsVerifyReceiptPostData): CancelablePromise<VerifyReceiptApiV1SubscriptionsVerifyReceiptPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/subscriptions/verify-receipt',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Get Subscription Status
     * Get current subscription status for authenticated user.
     *
     * Returns server-side subscription state.
     * Called by app when opening or returning to foreground.
     *
     * Error codes:
     * - 401_UNAUTHORIZED: Not logged in
     * - 503_SERVICE_UNAVAILABLE: Database unavailable
     * @returns SubscriptionStatusResponse Successful Response
     * @throws ApiError
     */
    public static getSubscriptionStatusApiV1SubscriptionsStatusGet(): CancelablePromise<GetSubscriptionStatusApiV1SubscriptionsStatusGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/subscriptions/status'
        });
    }
    
    /**
     * Expire Subscriptions
     * Expire active subscriptions that have passed their expiry date.
     *
     * This endpoint should be called by a scheduled background task (e.g., daily cron job).
     * For POC, it's exposed as an HTTP endpoint for manual triggering.
     *
     * In production, this should be:
     * - Protected by admin authentication or internal-only access
     * - Triggered by a scheduler (APScheduler, Celery Beat, Cloud Scheduler, etc.)
     *
     * Returns:
     * Number of subscriptions expired and processing timestamp
     * @returns ExpireSubscriptionsResponse Successful Response
     * @throws ApiError
     */
    public static expireSubscriptionsApiV1SubscriptionsExpireSubscriptionsPost(): CancelablePromise<ExpireSubscriptionsApiV1SubscriptionsExpireSubscriptionsPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/subscriptions/expire-subscriptions'
        });
    }
    
}

export class FriendsService {
    /**
     * Block a user
     * Block a user to prevent interaction. Required for FR-025 (blocking support).
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown Successful Response
     * @throws ApiError
     */
    public static blockUserApiV1FriendsBlockPost(data: BlockUserApiV1FriendsBlockPostData): CancelablePromise<BlockUserApiV1FriendsBlockPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/friends/block',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request',
                401: 'Unauthorized',
                422: 'Validation Error',
                500: 'Internal server error'
            }
        });
    }
    
    /**
     * Unblock a user
     * Unblock a previously blocked user. Required for FR-025.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown Successful Response
     * @throws ApiError
     */
    public static unblockUserApiV1FriendsUnblockPost(data: UnblockUserApiV1FriendsUnblockPostData): CancelablePromise<UnblockUserApiV1FriendsUnblockPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/friends/unblock',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request',
                401: 'Unauthorized',
                422: 'Validation Error',
                500: 'Internal server error'
            }
        });
    }
    
}

export class ReportsService {
    /**
     * Get my reports
     * Get reports submitted by the current user
     * @returns ReportListResponseWrapper Reports retrieved successfully
     * @throws ApiError
     */
    public static getMyReportsApiV1ReportsGet(): CancelablePromise<GetMyReportsApiV1ReportsGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/reports',
            errors: {
                401: 'Unauthorized (not logged in)',
                500: 'Internal server error'
            }
        });
    }
    
    /**
     * Submit report
     * Submit a report for inappropriate behavior or content
     * @param data The data for the request.
     * @param data.requestBody
     * @returns ReportResponseWrapper Report submitted successfully
     * @throws ApiError
     */
    public static submitReportApiV1ReportsPost(data: SubmitReportApiV1ReportsPostData): CancelablePromise<SubmitReportApiV1ReportsPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/reports',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad request (validation failed)',
                401: 'Unauthorized (not logged in)',
                422: 'Unprocessable entity (cannot report user)',
                500: 'Internal server error'
            }
        });
    }
    
}

export class CardsService {
    /**
     * Get upload signed URL
     * Generate a signed URL for uploading a card image to GCS
     * @param data The data for the request.
     * @param data.requestBody
     * @returns UploadUrlResponseWrapper Upload URL generated successfully
     * @throws ApiError
     */
    public static getUploadUrlApiV1CardsUploadUrlPost(data: GetUploadUrlApiV1CardsUploadUrlPostData): CancelablePromise<GetUploadUrlApiV1CardsUploadUrlPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/cards/upload-url',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Invalid request (file type/size)',
                401: 'Unauthorized',
                422: 'Quota exceeded'
            }
        });
    }
    
    /**
     * Get my cards
     * Retrieve all cards owned by the authenticated user
     * @param data The data for the request.
     * @param data.status Filter by status (available/trading/traded)
     * @returns CardListResponseWrapper Cards retrieved successfully
     * @throws ApiError
     */
    public static getMyCardsApiV1CardsMeGet(data: GetMyCardsApiV1CardsMeGetData = {}): CancelablePromise<GetMyCardsApiV1CardsMeGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/cards/me',
            query: {
                status: data.status
            },
            errors: {
                401: 'Unauthorized',
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Delete a card
     * Delete a card owned by the authenticated user
     * @param data The data for the request.
     * @param data.cardId
     * @returns DeleteSuccessResponseWrapper Card deleted successfully
     * @throws ApiError
     */
    public static deleteCardApiV1CardsCardIdDelete(data: DeleteCardApiV1CardsCardIdDeleteData): CancelablePromise<DeleteCardApiV1CardsCardIdDeleteResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/api/v1/cards/{card_id}',
            path: {
                card_id: data.cardId
            },
            errors: {
                401: 'Unauthorized',
                403: 'Not the card owner',
                404: 'Card not found',
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Get quota status
     * Check current upload quota usage
     * @returns QuotaStatusResponseWrapper Quota status retrieved successfully
     * @throws ApiError
     */
    public static getQuotaStatusApiV1CardsQuotaStatusGet(): CancelablePromise<GetQuotaStatusApiV1CardsQuotaStatusGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/cards/quota/status',
            errors: {
                401: 'Unauthorized'
            }
        });
    }
    
    /**
     * Confirm card upload
     * Confirm that the card image has been successfully uploaded to GCS after using the signed URL
     * @param data The data for the request.
     * @param data.cardId
     * @returns DeleteSuccessResponseWrapper Upload confirmed successfully
     * @throws ApiError
     */
    public static confirmCardUploadApiV1CardsCardIdConfirmUploadPost(data: ConfirmCardUploadApiV1CardsCardIdConfirmUploadPostData): CancelablePromise<ConfirmCardUploadApiV1CardsCardIdConfirmUploadPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/cards/{card_id}/confirm-upload',
            path: {
                card_id: data.cardId
            },
            errors: {
                400: 'Invalid request (already confirmed, no image, etc.)',
                401: 'Unauthorized',
                403: 'Not the card owner',
                404: 'Card not found or image not found in storage',
                422: 'Validation Error'
            }
        });
    }
    
}

export class ChatService {
    /**
     * Get chat rooms
     * Get all chat rooms for the current user
     * @returns ChatRoomListResponseWrapper Chat rooms retrieved successfully
     * @throws ApiError
     */
    public static getChatRoomsApiV1ChatsGet(): CancelablePromise<GetChatRoomsApiV1ChatsGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/chats',
            errors: {
                401: 'Unauthorized (not logged in)',
                500: 'Internal server error'
            }
        });
    }
    
    /**
     * Get messages
     * Get messages from a chat room (with pagination support via after_message_id)
     * @param data The data for the request.
     * @param data.roomId
     * @param data.afterMessageId Get messages after this message ID
     * @param data.limit Maximum number of messages
     * @returns MessagesListResponseWrapper Messages retrieved successfully
     * @throws ApiError
     */
    public static getMessagesApiV1ChatsRoomIdMessagesGet(data: GetMessagesApiV1ChatsRoomIdMessagesGetData): CancelablePromise<GetMessagesApiV1ChatsRoomIdMessagesGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/chats/{room_id}/messages',
            path: {
                room_id: data.roomId
            },
            query: {
                after_message_id: data.afterMessageId,
                limit: data.limit
            },
            errors: {
                401: 'Unauthorized (not logged in)',
                403: 'Forbidden (not a participant of this room)',
                404: 'Chat room not found',
                422: 'Validation Error',
                500: 'Internal server error'
            }
        });
    }
    
    /**
     * Send message
     * Send a message in a chat room (triggers FCM push notification)
     * @param data The data for the request.
     * @param data.roomId
     * @param data.requestBody
     * @returns MessageResponseWrapper Message sent successfully
     * @throws ApiError
     */
    public static sendMessageApiV1ChatsRoomIdMessagesPost(data: SendMessageApiV1ChatsRoomIdMessagesPostData): CancelablePromise<SendMessageApiV1ChatsRoomIdMessagesPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/chats/{room_id}/messages',
            path: {
                room_id: data.roomId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad request (validation failed)',
                401: 'Unauthorized (not logged in)',
                403: 'Forbidden (not authorized to send message)',
                404: 'Chat room not found',
                422: 'Unprocessable entity (blocked or not friends)',
                500: 'Internal server error'
            }
        });
    }
    
    /**
     * Mark message as read
     * Mark a message as read by the current user
     * @param data The data for the request.
     * @param data.roomId
     * @param data.messageId
     * @returns void Message marked as read
     * @throws ApiError
     */
    public static markMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPost(data: MarkMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostData): CancelablePromise<MarkMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/chats/{room_id}/messages/{message_id}/read',
            path: {
                room_id: data.roomId,
                message_id: data.messageId
            },
            errors: {
                401: 'Unauthorized (not logged in)',
                403: 'Forbidden (not authorized)',
                404: 'Message not found',
                422: 'Validation Error',
                500: 'Internal server error'
            }
        });
    }
    
}

export class PostsService {
    /**
     * Create a new post (V2: with scope/category)
     * Create a new post. Requires authentication. Free users limited to 2 posts per day, Premium to 20.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns PostResponseWrapper Post created successfully
     * @throws ApiError
     */
    public static createPostApiV1PostsPost(data: CreatePostApiV1PostsPostData): CancelablePromise<CreatePostApiV1PostsPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/posts',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad request (validation failed)',
                401: 'Unauthorized (not logged in)',
                422: 'Unprocessable entity (daily limit exceeded or validation failed)',
                500: 'Internal server error'
            }
        });
    }
    
    /**
     * List posts (V2: global/city filtering with category)
     * List posts. FR-005: Global view (no city_code) shows all posts; City view (with city_code) shows city-specific posts.
     * @param data The data for the request.
     * @param data.cityCode Optional city filter (omit for global view)
     * @param data.category Optional category filter
     * @param data.limit Maximum results
     * @param data.offset Pagination offset
     * @returns PostListResponseWrapper Posts retrieved successfully
     * @throws ApiError
     */
    public static listPostsApiV1PostsGet(data: ListPostsApiV1PostsGetData = {}): CancelablePromise<ListPostsApiV1PostsGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/posts',
            query: {
                city_code: data.cityCode,
                category: data.category,
                limit: data.limit,
                offset: data.offset
            },
            errors: {
                400: 'Bad request',
                401: 'Unauthorized (not logged in)',
                422: 'Validation Error',
                500: 'Internal server error'
            }
        });
    }
    
    /**
     * Close a post
     * Manually close a post. Only post owner can close.
     * @param data The data for the request.
     * @param data.postId
     * @returns void Post closed successfully
     * @throws ApiError
     */
    public static closePostApiV1PostsPostIdClosePost(data: ClosePostApiV1PostsPostIdClosePostData): CancelablePromise<ClosePostApiV1PostsPostIdClosePostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/posts/{post_id}/close',
            path: {
                post_id: data.postId
            },
            errors: {
                401: 'Unauthorized (not logged in)',
                403: 'Forbidden (not post owner)',
                404: 'Post not found',
                422: 'Unprocessable entity (post not open)',
                500: 'Internal server error'
            }
        });
    }
    
    /**
     * Toggle like on a post (FR-008, FR-009)
     * Like or unlike a post. Idempotent: if already liked, unlikes; if not liked, likes. Each user can like a post at most once.
     * @param data The data for the request.
     * @param data.postId
     * @returns ToggleLikeResponseWrapper Like toggled successfully
     * @throws ApiError
     */
    public static toggleLikeApiV1PostsPostIdLikePost(data: ToggleLikeApiV1PostsPostIdLikePostData): CancelablePromise<ToggleLikeApiV1PostsPostIdLikePostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/posts/{post_id}/like',
            path: {
                post_id: data.postId
            },
            errors: {
                401: 'Unauthorized (not logged in)',
                404: 'Post not found',
                422: 'Validation Error',
                500: 'Internal server error'
            }
        });
    }
    
}

export class LocationsService {
    /**
     * Get all Taiwan cities
     * Get a list of all available Taiwan cities/counties.
     *
     * This endpoint provides the complete list of Taiwan's 22 cities/counties including:
     * - **Six Special Municipalities** (Áõ¥ËΩÑÂ∏Ç): Taipei, New Taipei, Taoyuan, Taichung, Tainan, Kaohsiung
     * - **Provincial Cities** (ÁúÅËΩÑÂ∏Ç): Hsinchu City, Chiayi City
     * - **Counties** (Á∏£): Hsinchu County, Miaoli, Changhua, Nantou, Yunlin, Chiayi County, Pingtung, Yilan, Hualien, Taitung, Penghu, Kinmen, Lienchiang
     *
     * Each city includes:
     * - `code`: City code used in APIs (e.g., TPE, NTP, TAO)
     * - `name`: English name (e.g., Taipei City)
     * - `name_zh`: Chinese name (e.g., Âè∞ÂåóÂ∏Ç)
     *
     * This is a public endpoint that **does not require authentication**.
     * Frontend applications should use this to dynamically populate city selection dropdowns.
     * @returns CityListResponseWrapper List of all Taiwan cities retrieved successfully
     * @throws ApiError
     */
    public static getCitiesApiV1LocationsCitiesGet(): CancelablePromise<GetCitiesApiV1LocationsCitiesGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/locations/cities'
        });
    }
    
}

export class GalleryService {
    /**
     * Get user's gallery cards
     * View another user's public gallery cards (requires authentication).
     * @param data The data for the request.
     * @param data.userId
     * @returns GalleryCardListResponse Successful Response
     * @throws ApiError
     */
    public static getUserGalleryCardsApiV1UsersUserIdGalleryCardsGet(data: GetUserGalleryCardsApiV1UsersUserIdGalleryCardsGetData): CancelablePromise<GetUserGalleryCardsApiV1UsersUserIdGalleryCardsGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/users/{user_id}/gallery/cards',
            path: {
                user_id: data.userId
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Get my gallery cards
     * Get the authenticated user's own gallery cards.
     * @returns GalleryCardListResponse Successful Response
     * @throws ApiError
     */
    public static getMyGalleryCardsApiV1GalleryCardsMeGet(): CancelablePromise<GetMyGalleryCardsApiV1GalleryCardsMeGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/gallery/cards/me'
        });
    }
    
    /**
     * Create gallery card
     * Create a new gallery card in the user's personal album.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns GalleryCardResponse Successful Response
     * @throws ApiError
     */
    public static createGalleryCardApiV1GalleryCardsPost(data: CreateGalleryCardApiV1GalleryCardsPostData): CancelablePromise<CreateGalleryCardApiV1GalleryCardsPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/gallery/cards',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Delete gallery card
     * Delete a gallery card (only owner can delete).
     * @param data The data for the request.
     * @param data.cardId
     * @returns void Successful Response
     * @throws ApiError
     */
    public static deleteGalleryCardApiV1GalleryCardsCardIdDelete(data: DeleteGalleryCardApiV1GalleryCardsCardIdDeleteData): CancelablePromise<DeleteGalleryCardApiV1GalleryCardsCardIdDeleteResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/api/v1/gallery/cards/{card_id}',
            path: {
                card_id: data.cardId
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Reorder gallery cards
     * Update the display order of gallery cards.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns ReorderGalleryCardsResponse Successful Response
     * @throws ApiError
     */
    public static reorderGalleryCardsApiV1GalleryCardsReorderPut(data: ReorderGalleryCardsApiV1GalleryCardsReorderPutData): CancelablePromise<ReorderGalleryCardsApiV1GalleryCardsReorderPutResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/api/v1/gallery/cards/reorder',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
}

export class MediaService {
    /**
     * Generate presigned upload URL
     * Step 1: Generate a presigned URL for uploading media to GCS. FR-006.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns CreateUploadUrlResponseSchema Successful Response
     * @throws ApiError
     */
    public static createUploadUrlApiV1MediaUploadUrlPost(data: CreateUploadUrlApiV1MediaUploadUrlPostData): CancelablePromise<CreateUploadUrlApiV1MediaUploadUrlPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/media/upload-url',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Confirm media upload
     * Step 2: Confirm that media was uploaded to GCS. Applies quota. FR-022, T052.
     * @param data The data for the request.
     * @param data.mediaId
     * @returns ConfirmUploadResponseSchema Successful Response
     * @throws ApiError
     */
    public static confirmUploadApiV1MediaMediaIdConfirmPost(data: ConfirmUploadApiV1MediaMediaIdConfirmPostData): CancelablePromise<ConfirmUploadApiV1MediaMediaIdConfirmPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/media/{media_id}/confirm',
            path: {
                media_id: data.mediaId
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Attach media to post
     * Step 3: Attach confirmed media to a post. FR-007.
     * @param data The data for the request.
     * @param data.postId
     * @param data.requestBody
     * @returns AttachMediaResponseSchema Successful Response
     * @throws ApiError
     */
    public static attachMediaToPostApiV1MediaPostsPostIdAttachPost(data: AttachMediaToPostApiV1MediaPostsPostIdAttachPostData): CancelablePromise<AttachMediaToPostApiV1MediaPostsPostIdAttachPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/media/posts/{post_id}/attach',
            path: {
                post_id: data.postId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Attach media to gallery card
     * Step 3: Attach confirmed media to a gallery card. FR-007, FR-020.
     * @param data The data for the request.
     * @param data.cardId
     * @param data.requestBody
     * @returns AttachMediaResponseSchema Successful Response
     * @throws ApiError
     */
    public static attachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPost(data: AttachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostData): CancelablePromise<AttachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/media/gallery/cards/{card_id}/attach',
            path: {
                card_id: data.cardId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
}

export class MessageRequestsService {
    /**
     * Create Message Request
     * Create a message request to another user.
     *
     * Implements FR-011: Message Requests for strangers.
     * Implements FR-013: Privacy setting to block stranger messages.
     * Implements FR-014: One unique thread per user pair.
     * @param data The data for the request.
     * @param data.requestBody
     * @returns MessageRequestResponse Successful Response
     * @throws ApiError
     */
    public static createMessageRequestApiV1MessageRequestsPost(data: CreateMessageRequestApiV1MessageRequestsPostData): CancelablePromise<CreateMessageRequestApiV1MessageRequestsPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/message-requests',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Get My Message Requests
     * Get message requests for the current user.
     *
     * Supports FR-016: Inbox clearly separates Requests vs Threads.
     *
     * Query params:
     * - status_filter: "pending", "accepted", "declined", or "all" (default: "pending")
     * @param data The data for the request.
     * @param data.statusFilter
     * @returns MessageRequestResponse Successful Response
     * @throws ApiError
     */
    public static getMyMessageRequestsApiV1MessageRequestsInboxGet(data: GetMyMessageRequestsApiV1MessageRequestsInboxGetData = {}): CancelablePromise<GetMyMessageRequestsApiV1MessageRequestsInboxGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/message-requests/inbox',
            query: {
                status_filter: data.statusFilter
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Accept Message Request
     * Accept a message request and create a thread.
     *
     * Implements FR-012: Recipient can accept/decline requests.
     * Creates unique thread (FR-014).
     * @param data The data for the request.
     * @param data.requestId
     * @returns AcceptRequestResponse Successful Response
     * @throws ApiError
     */
    public static acceptMessageRequestApiV1MessageRequestsRequestIdAcceptPost(data: AcceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostData): CancelablePromise<AcceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/message-requests/{request_id}/accept',
            path: {
                request_id: data.requestId
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Decline Message Request
     * Decline a message request.
     *
     * Implements FR-012: Recipient can accept/decline requests.
     * @param data The data for the request.
     * @param data.requestId
     * @returns MessageRequestResponse Successful Response
     * @throws ApiError
     */
    public static declineMessageRequestApiV1MessageRequestsRequestIdDeclinePost(data: DeclineMessageRequestApiV1MessageRequestsRequestIdDeclinePostData): CancelablePromise<DeclineMessageRequestApiV1MessageRequestsRequestIdDeclinePostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/message-requests/{request_id}/decline',
            path: {
                request_id: data.requestId
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
}

export class ThreadsService {
    /**
     * Get My Threads
     * Get all threads for the current user.
     *
     * Supports FR-016: Inbox clearly separates Requests vs Threads.
     * Returns threads ordered by last_message_at descending.
     * @param data The data for the request.
     * @param data.limit
     * @param data.offset
     * @returns ThreadListResponse Successful Response
     * @throws ApiError
     */
    public static getMyThreadsApiV1ThreadsGet(data: GetMyThreadsApiV1ThreadsGetData = {}): CancelablePromise<GetMyThreadsApiV1ThreadsGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/threads',
            query: {
                limit: data.limit,
                offset: data.offset
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Get Thread Messages
     * Get messages in a thread.
     *
     * Returns messages ordered by created_at ascending (oldest first).
     * User must be part of the thread to view messages.
     * @param data The data for the request.
     * @param data.threadId
     * @param data.limit
     * @param data.offset
     * @returns ThreadMessagesResponse Successful Response
     * @throws ApiError
     */
    public static getThreadMessagesApiV1ThreadsThreadIdMessagesGet(data: GetThreadMessagesApiV1ThreadsThreadIdMessagesGetData): CancelablePromise<GetThreadMessagesApiV1ThreadsThreadIdMessagesGetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/threads/{thread_id}/messages',
            path: {
                thread_id: data.threadId
            },
            query: {
                limit: data.limit,
                offset: data.offset
            },
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
    /**
     * Send Message
     * Send a message in a thread.
     *
     * Supports FR-015: Messages can reference post_id.
     * User must be part of the thread to send messages.
     * @param data The data for the request.
     * @param data.threadId
     * @param data.requestBody
     * @returns ThreadMessageResponse Successful Response
     * @throws ApiError
     */
    public static sendMessageApiV1ThreadsThreadIdMessagesPost(data: SendMessageApiV1ThreadsThreadIdMessagesPostData): CancelablePromise<SendMessageApiV1ThreadsThreadIdMessagesPostResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/threads/{thread_id}/messages',
            path: {
                thread_id: data.threadId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                422: 'Validation Error'
            }
        });
    }
    
}