// This file is auto-generated by @hey-api/openapi-ts

import {
  type DefaultError,
  type InfiniteData,
  infiniteQueryOptions,
  queryOptions,
  type UseMutationOptions,
} from '@tanstack/react-query';

import { client } from '../client.gen';
import {
  acceptMessageRequestApiV1MessageRequestsRequestIdAcceptPost,
  adminLoginApiV1AuthAdminLoginPost,
  apiHealthCheckApiV1HealthGet,
  attachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPost,
  attachMediaToPostApiV1MediaPostsPostIdAttachPost,
  blockUserApiV1FriendsBlockPost,
  closePostApiV1PostsPostIdClosePost,
  confirmUploadApiV1MediaMediaIdConfirmPost,
  createGalleryCardApiV1GalleryCardsPost,
  createMessageRequestApiV1MessageRequestsPost,
  createPostApiV1PostsPost,
  createPostCommentApiV1PostsPostIdCommentsPost,
  createUploadUrlApiV1MediaUploadUrlPost,
  declineMessageRequestApiV1MessageRequestsRequestIdDeclinePost,
  deleteGalleryCardApiV1GalleryCardsCardIdDelete,
  expireSubscriptionsApiV1SubscriptionsExpireSubscriptionsPost,
  getCategoriesApiV1PostsCategoriesGet,
  getChatRoomsApiV1ChatsGet,
  getCitiesApiV1LocationsCitiesGet,
  getIdolGroupsApiV1IdolsGroupsGet,
  getMediaReadUrlsApiV1MediaReadUrlsPost,
  getMessagesApiV1ChatsRoomIdMessagesGet,
  getMyGalleryCardsApiV1GalleryCardsMeGet,
  getMyMessageRequestsApiV1MessageRequestsInboxGet,
  getMyProfileApiV1ProfileMeGet,
  getMyReportsApiV1ReportsGet,
  getMySentMessageRequestsApiV1MessageRequestsSentGet,
  getMyThreadsApiV1ThreadsGet,
  getPostApiV1PostsPostIdGet,
  getSubscriptionStatusApiV1SubscriptionsStatusGet,
  getThreadMessagesApiV1ThreadsThreadIdMessagesGet,
  getUserGalleryCardsApiV1UsersUserIdGalleryCardsGet,
  googleCallbackApiV1AuthGoogleCallbackPost,
  googleLoginApiV1AuthGoogleLoginPost,
  googleLoginCodeApiV1AuthGoogleLoginCodePost,
  healthCheckHealthGet,
  listPostCommentsApiV1PostsPostIdCommentsGet,
  listPostsApiV1PostsGet,
  logoutApiV1AuthLogoutPost,
  markMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPost,
  type Options,
  refreshTokenApiV1AuthRefreshPost,
  reorderGalleryCardsApiV1GalleryCardsReorderPut,
  rootGet,
  sendMessageApiV1ChatsRoomIdMessagesPost,
  sendMessageApiV1ThreadsThreadIdMessagesPost,
  submitReportApiV1ReportsPost,
  toggleLikeApiV1PostsPostIdLikePost,
  unblockUserApiV1FriendsUnblockPost,
  updateMyProfileApiV1ProfileMePut,
  verifyReceiptApiV1SubscriptionsVerifyReceiptPost,
} from '../sdk.gen';
import type {
  AcceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostData,
  AcceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostError,
  AcceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostResponse,
  AdminLoginApiV1AuthAdminLoginPostData,
  AdminLoginApiV1AuthAdminLoginPostError,
  AdminLoginApiV1AuthAdminLoginPostResponse,
  ApiHealthCheckApiV1HealthGetData,
  AttachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostData,
  AttachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostError,
  AttachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostResponse,
  AttachMediaToPostApiV1MediaPostsPostIdAttachPostData,
  AttachMediaToPostApiV1MediaPostsPostIdAttachPostError,
  AttachMediaToPostApiV1MediaPostsPostIdAttachPostResponse,
  BlockUserApiV1FriendsBlockPostData,
  BlockUserApiV1FriendsBlockPostError,
  BlockUserApiV1FriendsBlockPostResponse,
  ClosePostApiV1PostsPostIdClosePostData,
  ClosePostApiV1PostsPostIdClosePostResponse,
  ConfirmUploadApiV1MediaMediaIdConfirmPostData,
  ConfirmUploadApiV1MediaMediaIdConfirmPostError,
  ConfirmUploadApiV1MediaMediaIdConfirmPostResponse,
  CreateGalleryCardApiV1GalleryCardsPostData,
  CreateGalleryCardApiV1GalleryCardsPostError,
  CreateGalleryCardApiV1GalleryCardsPostResponse,
  CreateMessageRequestApiV1MessageRequestsPostData,
  CreateMessageRequestApiV1MessageRequestsPostError,
  CreateMessageRequestApiV1MessageRequestsPostResponse,
  CreatePostApiV1PostsPostData,
  CreatePostApiV1PostsPostResponse,
  CreatePostCommentApiV1PostsPostIdCommentsPostData,
  CreatePostCommentApiV1PostsPostIdCommentsPostError,
  CreatePostCommentApiV1PostsPostIdCommentsPostResponse,
  CreateUploadUrlApiV1MediaUploadUrlPostData,
  CreateUploadUrlApiV1MediaUploadUrlPostError,
  CreateUploadUrlApiV1MediaUploadUrlPostResponse,
  DeclineMessageRequestApiV1MessageRequestsRequestIdDeclinePostData,
  DeclineMessageRequestApiV1MessageRequestsRequestIdDeclinePostError,
  DeclineMessageRequestApiV1MessageRequestsRequestIdDeclinePostResponse,
  DeleteGalleryCardApiV1GalleryCardsCardIdDeleteData,
  DeleteGalleryCardApiV1GalleryCardsCardIdDeleteError,
  DeleteGalleryCardApiV1GalleryCardsCardIdDeleteResponse,
  ExpireSubscriptionsApiV1SubscriptionsExpireSubscriptionsPostData,
  ExpireSubscriptionsApiV1SubscriptionsExpireSubscriptionsPostResponse,
  GetCategoriesApiV1PostsCategoriesGetData,
  GetCategoriesApiV1PostsCategoriesGetResponse,
  GetChatRoomsApiV1ChatsGetData,
  GetChatRoomsApiV1ChatsGetError,
  GetChatRoomsApiV1ChatsGetResponse,
  GetCitiesApiV1LocationsCitiesGetData,
  GetCitiesApiV1LocationsCitiesGetResponse,
  GetIdolGroupsApiV1IdolsGroupsGetData,
  GetIdolGroupsApiV1IdolsGroupsGetResponse,
  GetMediaReadUrlsApiV1MediaReadUrlsPostData,
  GetMediaReadUrlsApiV1MediaReadUrlsPostError,
  GetMediaReadUrlsApiV1MediaReadUrlsPostResponse,
  GetMessagesApiV1ChatsRoomIdMessagesGetData,
  GetMessagesApiV1ChatsRoomIdMessagesGetError,
  GetMessagesApiV1ChatsRoomIdMessagesGetResponse,
  GetMyGalleryCardsApiV1GalleryCardsMeGetData,
  GetMyGalleryCardsApiV1GalleryCardsMeGetError,
  GetMyGalleryCardsApiV1GalleryCardsMeGetResponse,
  GetMyMessageRequestsApiV1MessageRequestsInboxGetData,
  GetMyMessageRequestsApiV1MessageRequestsInboxGetError,
  GetMyMessageRequestsApiV1MessageRequestsInboxGetResponse,
  GetMyProfileApiV1ProfileMeGetData,
  GetMyProfileApiV1ProfileMeGetError,
  GetMyProfileApiV1ProfileMeGetResponse,
  GetMyReportsApiV1ReportsGetData,
  GetMyReportsApiV1ReportsGetError,
  GetMyReportsApiV1ReportsGetResponse,
  GetMySentMessageRequestsApiV1MessageRequestsSentGetData,
  GetMySentMessageRequestsApiV1MessageRequestsSentGetError,
  GetMySentMessageRequestsApiV1MessageRequestsSentGetResponse,
  GetMyThreadsApiV1ThreadsGetData,
  GetMyThreadsApiV1ThreadsGetError,
  GetMyThreadsApiV1ThreadsGetResponse,
  GetPostApiV1PostsPostIdGetData,
  GetPostApiV1PostsPostIdGetError,
  GetPostApiV1PostsPostIdGetResponse,
  GetSubscriptionStatusApiV1SubscriptionsStatusGetData,
  GetSubscriptionStatusApiV1SubscriptionsStatusGetError,
  GetSubscriptionStatusApiV1SubscriptionsStatusGetResponse,
  GetThreadMessagesApiV1ThreadsThreadIdMessagesGetData,
  GetThreadMessagesApiV1ThreadsThreadIdMessagesGetError,
  GetThreadMessagesApiV1ThreadsThreadIdMessagesGetResponse,
  GetUserGalleryCardsApiV1UsersUserIdGalleryCardsGetData,
  GetUserGalleryCardsApiV1UsersUserIdGalleryCardsGetError,
  GetUserGalleryCardsApiV1UsersUserIdGalleryCardsGetResponse,
  GoogleCallbackApiV1AuthGoogleCallbackPostData,
  GoogleCallbackApiV1AuthGoogleCallbackPostResponse,
  GoogleLoginApiV1AuthGoogleLoginPostData,
  GoogleLoginApiV1AuthGoogleLoginPostError,
  GoogleLoginApiV1AuthGoogleLoginPostResponse,
  GoogleLoginCodeApiV1AuthGoogleLoginCodePostData,
  GoogleLoginCodeApiV1AuthGoogleLoginCodePostResponse,
  HealthCheckHealthGetData,
  ListPostCommentsApiV1PostsPostIdCommentsGetData,
  ListPostCommentsApiV1PostsPostIdCommentsGetError,
  ListPostCommentsApiV1PostsPostIdCommentsGetResponse,
  ListPostsApiV1PostsGetData,
  ListPostsApiV1PostsGetError,
  ListPostsApiV1PostsGetResponse,
  LogoutApiV1AuthLogoutPostData,
  LogoutApiV1AuthLogoutPostResponse,
  MarkMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostData,
  MarkMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostError,
  MarkMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostResponse,
  RefreshTokenApiV1AuthRefreshPostData,
  RefreshTokenApiV1AuthRefreshPostError,
  RefreshTokenApiV1AuthRefreshPostResponse,
  ReorderGalleryCardsApiV1GalleryCardsReorderPutData,
  ReorderGalleryCardsApiV1GalleryCardsReorderPutError,
  ReorderGalleryCardsApiV1GalleryCardsReorderPutResponse,
  RootGetData,
  SendMessageApiV1ChatsRoomIdMessagesPostData,
  SendMessageApiV1ChatsRoomIdMessagesPostResponse,
  SendMessageApiV1ThreadsThreadIdMessagesPostData,
  SendMessageApiV1ThreadsThreadIdMessagesPostError,
  SendMessageApiV1ThreadsThreadIdMessagesPostResponse,
  SubmitReportApiV1ReportsPostData,
  SubmitReportApiV1ReportsPostResponse,
  ToggleLikeApiV1PostsPostIdLikePostData,
  ToggleLikeApiV1PostsPostIdLikePostError,
  ToggleLikeApiV1PostsPostIdLikePostResponse,
  UnblockUserApiV1FriendsUnblockPostData,
  UnblockUserApiV1FriendsUnblockPostError,
  UnblockUserApiV1FriendsUnblockPostResponse,
  UpdateMyProfileApiV1ProfileMePutData,
  UpdateMyProfileApiV1ProfileMePutError,
  UpdateMyProfileApiV1ProfileMePutResponse,
  VerifyReceiptApiV1SubscriptionsVerifyReceiptPostData,
  VerifyReceiptApiV1SubscriptionsVerifyReceiptPostError,
  VerifyReceiptApiV1SubscriptionsVerifyReceiptPostResponse,
} from '../types.gen';

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
    tags?: readonly string[];
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: readonly string[]
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const healthCheckHealthGetQueryKey = (options?: Options<HealthCheckHealthGetData>) =>
  createQueryKey('healthCheckHealthGet', options);

/**
 * Health Check
 *
 * Health check endpoint for container orchestration.
 */
export const healthCheckHealthGetOptions = (options?: Options<HealthCheckHealthGetData>) =>
  queryOptions<unknown, DefaultError, unknown, ReturnType<typeof healthCheckHealthGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await healthCheckHealthGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: healthCheckHealthGetQueryKey(options),
  });

export const apiHealthCheckApiV1HealthGetQueryKey = (
  options?: Options<ApiHealthCheckApiV1HealthGetData>
) => createQueryKey('apiHealthCheckApiV1HealthGet', options);

/**
 * Api Health Check
 *
 * API health check endpoint.
 */
export const apiHealthCheckApiV1HealthGetOptions = (
  options?: Options<ApiHealthCheckApiV1HealthGetData>
) =>
  queryOptions<
    unknown,
    DefaultError,
    unknown,
    ReturnType<typeof apiHealthCheckApiV1HealthGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiHealthCheckApiV1HealthGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiHealthCheckApiV1HealthGetQueryKey(options),
  });

export const rootGetQueryKey = (options?: Options<RootGetData>) =>
  createQueryKey('rootGet', options);

/**
 * Root
 *
 * Root endpoint.
 */
export const rootGetOptions = (options?: Options<RootGetData>) =>
  queryOptions<unknown, DefaultError, unknown, ReturnType<typeof rootGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rootGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rootGetQueryKey(options),
  });

/**
 * Admin login with email/password
 *
 * Authenticate admin user with email and password and receive JWT tokens via httpOnly cookies
 */
export const adminLoginApiV1AuthAdminLoginPostMutation = (
  options?: Partial<Options<AdminLoginApiV1AuthAdminLoginPostData>>
): UseMutationOptions<
  AdminLoginApiV1AuthAdminLoginPostResponse,
  AdminLoginApiV1AuthAdminLoginPostError,
  Options<AdminLoginApiV1AuthAdminLoginPostData>
> => {
  const mutationOptions: UseMutationOptions<
    AdminLoginApiV1AuthAdminLoginPostResponse,
    AdminLoginApiV1AuthAdminLoginPostError,
    Options<AdminLoginApiV1AuthAdminLoginPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await adminLoginApiV1AuthAdminLoginPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Login with Google
 *
 * Authenticate user with Google OAuth token and receive JWT tokens via httpOnly cookies
 */
export const googleLoginApiV1AuthGoogleLoginPostMutation = (
  options?: Partial<Options<GoogleLoginApiV1AuthGoogleLoginPostData>>
): UseMutationOptions<
  GoogleLoginApiV1AuthGoogleLoginPostResponse,
  GoogleLoginApiV1AuthGoogleLoginPostError,
  Options<GoogleLoginApiV1AuthGoogleLoginPostData>
> => {
  const mutationOptions: UseMutationOptions<
    GoogleLoginApiV1AuthGoogleLoginPostResponse,
    GoogleLoginApiV1AuthGoogleLoginPostError,
    Options<GoogleLoginApiV1AuthGoogleLoginPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await googleLoginApiV1AuthGoogleLoginPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Google OAuth Callback with PKCE
 *
 * Authenticate user with Google OAuth authorization code and PKCE code_verifier (Expo AuthSession)
 */
export const googleCallbackApiV1AuthGoogleCallbackPostMutation = (
  options?: Partial<Options<GoogleCallbackApiV1AuthGoogleCallbackPostData>>
): UseMutationOptions<
  GoogleCallbackApiV1AuthGoogleCallbackPostResponse,
  DefaultError,
  Options<GoogleCallbackApiV1AuthGoogleCallbackPostData>
> => {
  const mutationOptions: UseMutationOptions<
    GoogleCallbackApiV1AuthGoogleCallbackPostResponse,
    DefaultError,
    Options<GoogleCallbackApiV1AuthGoogleCallbackPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await googleCallbackApiV1AuthGoogleCallbackPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Login with Google authorization code
 *
 * Authenticate user with Google OAuth authorization code (Web flow without PKCE)
 */
export const googleLoginCodeApiV1AuthGoogleLoginCodePostMutation = (
  options?: Partial<Options<GoogleLoginCodeApiV1AuthGoogleLoginCodePostData>>
): UseMutationOptions<
  GoogleLoginCodeApiV1AuthGoogleLoginCodePostResponse,
  DefaultError,
  Options<GoogleLoginCodeApiV1AuthGoogleLoginCodePostData>
> => {
  const mutationOptions: UseMutationOptions<
    GoogleLoginCodeApiV1AuthGoogleLoginCodePostResponse,
    DefaultError,
    Options<GoogleLoginCodeApiV1AuthGoogleLoginCodePostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await googleLoginCodeApiV1AuthGoogleLoginCodePost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Refresh access token (cookie-based)
 *
 * Use refresh token from httpOnly cookie to obtain new access and refresh tokens
 */
export const refreshTokenApiV1AuthRefreshPostMutation = (
  options?: Partial<Options<RefreshTokenApiV1AuthRefreshPostData>>
): UseMutationOptions<
  RefreshTokenApiV1AuthRefreshPostResponse,
  RefreshTokenApiV1AuthRefreshPostError,
  Options<RefreshTokenApiV1AuthRefreshPostData>
> => {
  const mutationOptions: UseMutationOptions<
    RefreshTokenApiV1AuthRefreshPostResponse,
    RefreshTokenApiV1AuthRefreshPostError,
    Options<RefreshTokenApiV1AuthRefreshPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await refreshTokenApiV1AuthRefreshPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Logout and clear authentication cookies
 *
 * Clear access and refresh token cookies to log out the user
 */
export const logoutApiV1AuthLogoutPostMutation = (
  options?: Partial<Options<LogoutApiV1AuthLogoutPostData>>
): UseMutationOptions<
  LogoutApiV1AuthLogoutPostResponse,
  DefaultError,
  Options<LogoutApiV1AuthLogoutPostData>
> => {
  const mutationOptions: UseMutationOptions<
    LogoutApiV1AuthLogoutPostResponse,
    DefaultError,
    Options<LogoutApiV1AuthLogoutPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await logoutApiV1AuthLogoutPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getMyProfileApiV1ProfileMeGetQueryKey = (
  options?: Options<GetMyProfileApiV1ProfileMeGetData>
) => createQueryKey('getMyProfileApiV1ProfileMeGet', options);

/**
 * Get my profile
 *
 * Retrieve the authenticated user's profile information
 */
export const getMyProfileApiV1ProfileMeGetOptions = (
  options?: Options<GetMyProfileApiV1ProfileMeGetData>
) =>
  queryOptions<
    GetMyProfileApiV1ProfileMeGetResponse,
    GetMyProfileApiV1ProfileMeGetError,
    GetMyProfileApiV1ProfileMeGetResponse,
    ReturnType<typeof getMyProfileApiV1ProfileMeGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMyProfileApiV1ProfileMeGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMyProfileApiV1ProfileMeGetQueryKey(options),
  });

/**
 * Update my profile
 *
 * Update the authenticated user's profile information
 */
export const updateMyProfileApiV1ProfileMePutMutation = (
  options?: Partial<Options<UpdateMyProfileApiV1ProfileMePutData>>
): UseMutationOptions<
  UpdateMyProfileApiV1ProfileMePutResponse,
  UpdateMyProfileApiV1ProfileMePutError,
  Options<UpdateMyProfileApiV1ProfileMePutData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateMyProfileApiV1ProfileMePutResponse,
    UpdateMyProfileApiV1ProfileMePutError,
    Options<UpdateMyProfileApiV1ProfileMePutData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateMyProfileApiV1ProfileMePut({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getIdolGroupsApiV1IdolsGroupsGetQueryKey = (
  options?: Options<GetIdolGroupsApiV1IdolsGroupsGetData>
) => createQueryKey('getIdolGroupsApiV1IdolsGroupsGet', options);

/**
 * Get all idol groups
 *
 * Get a list of all available K-pop idol groups for onboarding.
 *
 * This endpoint provides the complete list of idol groups that users can select
 * during the onboarding process to indicate their preferences.
 *
 * Each idol group includes:
 * - `id`: Unique identifier (e.g., newjeans, ive, aespa)
 * - `name`: Display name (e.g., NewJeans, IVE, aespa)
 * - `emoji`: Emoji representing the group (e.g., üëñ, ü¶¢, ü¶ã)
 *
 * This is a **public endpoint** that **does not require authentication**.
 * Frontend applications should use this to dynamically populate idol group selection.
 */
export const getIdolGroupsApiV1IdolsGroupsGetOptions = (
  options?: Options<GetIdolGroupsApiV1IdolsGroupsGetData>
) =>
  queryOptions<
    GetIdolGroupsApiV1IdolsGroupsGetResponse,
    DefaultError,
    GetIdolGroupsApiV1IdolsGroupsGetResponse,
    ReturnType<typeof getIdolGroupsApiV1IdolsGroupsGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getIdolGroupsApiV1IdolsGroupsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getIdolGroupsApiV1IdolsGroupsGetQueryKey(options),
  });

/**
 * Verify Receipt
 *
 * Verify Google Play purchase receipt and update subscription.
 *
 * Features:
 * - Idempotent: Same token + same user returns current status
 * - Token binding: Prevents cross-user replay attacks
 * - Auto-acknowledge: Acknowledges purchase after verification
 *
 * Error codes:
 * - 400_VALIDATION_FAILED: Invalid platform or missing fields
 * - 401_UNAUTHORIZED: Not logged in
 * - 409_CONFLICT: Purchase token already used by another user
 * - 503_SERVICE_UNAVAILABLE: Google Play API unavailable
 */
export const verifyReceiptApiV1SubscriptionsVerifyReceiptPostMutation = (
  options?: Partial<Options<VerifyReceiptApiV1SubscriptionsVerifyReceiptPostData>>
): UseMutationOptions<
  VerifyReceiptApiV1SubscriptionsVerifyReceiptPostResponse,
  VerifyReceiptApiV1SubscriptionsVerifyReceiptPostError,
  Options<VerifyReceiptApiV1SubscriptionsVerifyReceiptPostData>
> => {
  const mutationOptions: UseMutationOptions<
    VerifyReceiptApiV1SubscriptionsVerifyReceiptPostResponse,
    VerifyReceiptApiV1SubscriptionsVerifyReceiptPostError,
    Options<VerifyReceiptApiV1SubscriptionsVerifyReceiptPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await verifyReceiptApiV1SubscriptionsVerifyReceiptPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getSubscriptionStatusApiV1SubscriptionsStatusGetQueryKey = (
  options?: Options<GetSubscriptionStatusApiV1SubscriptionsStatusGetData>
) => createQueryKey('getSubscriptionStatusApiV1SubscriptionsStatusGet', options);

/**
 * Get Subscription Status
 *
 * Get current subscription status for authenticated user.
 *
 * Returns server-side subscription state.
 * Called by app when opening or returning to foreground.
 *
 * Error codes:
 * - 401_UNAUTHORIZED: Not logged in
 * - 503_SERVICE_UNAVAILABLE: Database unavailable
 */
export const getSubscriptionStatusApiV1SubscriptionsStatusGetOptions = (
  options?: Options<GetSubscriptionStatusApiV1SubscriptionsStatusGetData>
) =>
  queryOptions<
    GetSubscriptionStatusApiV1SubscriptionsStatusGetResponse,
    GetSubscriptionStatusApiV1SubscriptionsStatusGetError,
    GetSubscriptionStatusApiV1SubscriptionsStatusGetResponse,
    ReturnType<typeof getSubscriptionStatusApiV1SubscriptionsStatusGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getSubscriptionStatusApiV1SubscriptionsStatusGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getSubscriptionStatusApiV1SubscriptionsStatusGetQueryKey(options),
  });

/**
 * Expire Subscriptions
 *
 * Expire active subscriptions that have passed their expiry date.
 *
 * This endpoint should be called by a scheduled background task (e.g., daily cron job).
 * For POC, it's exposed as an HTTP endpoint for manual triggering.
 *
 * In production, this should be:
 * - Protected by admin authentication or internal-only access
 * - Triggered by a scheduler (APScheduler, Celery Beat, Cloud Scheduler, etc.)
 *
 * Returns:
 * Number of subscriptions expired and processing timestamp
 */
export const expireSubscriptionsApiV1SubscriptionsExpireSubscriptionsPostMutation = (
  options?: Partial<Options<ExpireSubscriptionsApiV1SubscriptionsExpireSubscriptionsPostData>>
): UseMutationOptions<
  ExpireSubscriptionsApiV1SubscriptionsExpireSubscriptionsPostResponse,
  DefaultError,
  Options<ExpireSubscriptionsApiV1SubscriptionsExpireSubscriptionsPostData>
> => {
  const mutationOptions: UseMutationOptions<
    ExpireSubscriptionsApiV1SubscriptionsExpireSubscriptionsPostResponse,
    DefaultError,
    Options<ExpireSubscriptionsApiV1SubscriptionsExpireSubscriptionsPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await expireSubscriptionsApiV1SubscriptionsExpireSubscriptionsPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Block a user
 *
 * Block a user to prevent interaction. Required for FR-025 (blocking support).
 */
export const blockUserApiV1FriendsBlockPostMutation = (
  options?: Partial<Options<BlockUserApiV1FriendsBlockPostData>>
): UseMutationOptions<
  BlockUserApiV1FriendsBlockPostResponse,
  BlockUserApiV1FriendsBlockPostError,
  Options<BlockUserApiV1FriendsBlockPostData>
> => {
  const mutationOptions: UseMutationOptions<
    BlockUserApiV1FriendsBlockPostResponse,
    BlockUserApiV1FriendsBlockPostError,
    Options<BlockUserApiV1FriendsBlockPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await blockUserApiV1FriendsBlockPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Unblock a user
 *
 * Unblock a previously blocked user. Required for FR-025.
 */
export const unblockUserApiV1FriendsUnblockPostMutation = (
  options?: Partial<Options<UnblockUserApiV1FriendsUnblockPostData>>
): UseMutationOptions<
  UnblockUserApiV1FriendsUnblockPostResponse,
  UnblockUserApiV1FriendsUnblockPostError,
  Options<UnblockUserApiV1FriendsUnblockPostData>
> => {
  const mutationOptions: UseMutationOptions<
    UnblockUserApiV1FriendsUnblockPostResponse,
    UnblockUserApiV1FriendsUnblockPostError,
    Options<UnblockUserApiV1FriendsUnblockPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await unblockUserApiV1FriendsUnblockPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getMyReportsApiV1ReportsGetQueryKey = (
  options?: Options<GetMyReportsApiV1ReportsGetData>
) => createQueryKey('getMyReportsApiV1ReportsGet', options);

/**
 * Get my reports
 *
 * Get reports submitted by the current user
 */
export const getMyReportsApiV1ReportsGetOptions = (
  options?: Options<GetMyReportsApiV1ReportsGetData>
) =>
  queryOptions<
    GetMyReportsApiV1ReportsGetResponse,
    GetMyReportsApiV1ReportsGetError,
    GetMyReportsApiV1ReportsGetResponse,
    ReturnType<typeof getMyReportsApiV1ReportsGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMyReportsApiV1ReportsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMyReportsApiV1ReportsGetQueryKey(options),
  });

/**
 * Submit report
 *
 * Submit a report for inappropriate behavior or content
 */
export const submitReportApiV1ReportsPostMutation = (
  options?: Partial<Options<SubmitReportApiV1ReportsPostData>>
): UseMutationOptions<
  SubmitReportApiV1ReportsPostResponse,
  DefaultError,
  Options<SubmitReportApiV1ReportsPostData>
> => {
  const mutationOptions: UseMutationOptions<
    SubmitReportApiV1ReportsPostResponse,
    DefaultError,
    Options<SubmitReportApiV1ReportsPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await submitReportApiV1ReportsPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getChatRoomsApiV1ChatsGetQueryKey = (
  options?: Options<GetChatRoomsApiV1ChatsGetData>
) => createQueryKey('getChatRoomsApiV1ChatsGet', options);

/**
 * Get chat rooms
 *
 * Get all chat rooms for the current user
 */
export const getChatRoomsApiV1ChatsGetOptions = (
  options?: Options<GetChatRoomsApiV1ChatsGetData>
) =>
  queryOptions<
    GetChatRoomsApiV1ChatsGetResponse,
    GetChatRoomsApiV1ChatsGetError,
    GetChatRoomsApiV1ChatsGetResponse,
    ReturnType<typeof getChatRoomsApiV1ChatsGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getChatRoomsApiV1ChatsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getChatRoomsApiV1ChatsGetQueryKey(options),
  });

export const getMessagesApiV1ChatsRoomIdMessagesGetQueryKey = (
  options: Options<GetMessagesApiV1ChatsRoomIdMessagesGetData>
) => createQueryKey('getMessagesApiV1ChatsRoomIdMessagesGet', options);

/**
 * Get messages
 *
 * Get messages from a chat room (with pagination support via after_message_id)
 */
export const getMessagesApiV1ChatsRoomIdMessagesGetOptions = (
  options: Options<GetMessagesApiV1ChatsRoomIdMessagesGetData>
) =>
  queryOptions<
    GetMessagesApiV1ChatsRoomIdMessagesGetResponse,
    GetMessagesApiV1ChatsRoomIdMessagesGetError,
    GetMessagesApiV1ChatsRoomIdMessagesGetResponse,
    ReturnType<typeof getMessagesApiV1ChatsRoomIdMessagesGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMessagesApiV1ChatsRoomIdMessagesGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMessagesApiV1ChatsRoomIdMessagesGetQueryKey(options),
  });

/**
 * Send message
 *
 * Send a message in a chat room (triggers FCM push notification)
 */
export const sendMessageApiV1ChatsRoomIdMessagesPostMutation = (
  options?: Partial<Options<SendMessageApiV1ChatsRoomIdMessagesPostData>>
): UseMutationOptions<
  SendMessageApiV1ChatsRoomIdMessagesPostResponse,
  DefaultError,
  Options<SendMessageApiV1ChatsRoomIdMessagesPostData>
> => {
  const mutationOptions: UseMutationOptions<
    SendMessageApiV1ChatsRoomIdMessagesPostResponse,
    DefaultError,
    Options<SendMessageApiV1ChatsRoomIdMessagesPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await sendMessageApiV1ChatsRoomIdMessagesPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Mark message as read
 *
 * Mark a message as read by the current user
 */
export const markMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostMutation = (
  options?: Partial<Options<MarkMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostData>>
): UseMutationOptions<
  MarkMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostResponse,
  MarkMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostError,
  Options<MarkMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostData>
> => {
  const mutationOptions: UseMutationOptions<
    MarkMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostResponse,
    MarkMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostError,
    Options<MarkMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await markMessageReadApiV1ChatsRoomIdMessagesMessageIdReadPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCategoriesApiV1PostsCategoriesGetQueryKey = (
  options?: Options<GetCategoriesApiV1PostsCategoriesGetData>
) => createQueryKey('getCategoriesApiV1PostsCategoriesGet', options);

/**
 * Get available post categories
 *
 * Returns list of all available post categories with their labels
 */
export const getCategoriesApiV1PostsCategoriesGetOptions = (
  options?: Options<GetCategoriesApiV1PostsCategoriesGetData>
) =>
  queryOptions<
    GetCategoriesApiV1PostsCategoriesGetResponse,
    DefaultError,
    GetCategoriesApiV1PostsCategoriesGetResponse,
    ReturnType<typeof getCategoriesApiV1PostsCategoriesGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCategoriesApiV1PostsCategoriesGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCategoriesApiV1PostsCategoriesGetQueryKey(options),
  });

export const listPostsApiV1PostsGetQueryKey = (options?: Options<ListPostsApiV1PostsGetData>) =>
  createQueryKey('listPostsApiV1PostsGet', options);

/**
 * List posts (V2: global/city filtering with category)
 *
 * List posts. FR-005: Global view (no city_code) shows all posts; City view (with city_code) shows city-specific posts.
 */
export const listPostsApiV1PostsGetOptions = (options?: Options<ListPostsApiV1PostsGetData>) =>
  queryOptions<
    ListPostsApiV1PostsGetResponse,
    ListPostsApiV1PostsGetError,
    ListPostsApiV1PostsGetResponse,
    ReturnType<typeof listPostsApiV1PostsGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listPostsApiV1PostsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listPostsApiV1PostsGetQueryKey(options),
  });

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
  queryKey: QueryKey<Options>,
  page: K
) => {
  const params = { ...queryKey[0] };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const listPostsApiV1PostsGetInfiniteQueryKey = (
  options?: Options<ListPostsApiV1PostsGetData>
): QueryKey<Options<ListPostsApiV1PostsGetData>> =>
  createQueryKey('listPostsApiV1PostsGet', options, true);

/**
 * List posts (V2: global/city filtering with category)
 *
 * List posts. FR-005: Global view (no city_code) shows all posts; City view (with city_code) shows city-specific posts.
 */
export const listPostsApiV1PostsGetInfiniteOptions = (
  options?: Options<ListPostsApiV1PostsGetData>
) =>
  infiniteQueryOptions<
    ListPostsApiV1PostsGetResponse,
    ListPostsApiV1PostsGetError,
    InfiniteData<ListPostsApiV1PostsGetResponse>,
    QueryKey<Options<ListPostsApiV1PostsGetData>>,
    | number
    | Pick<QueryKey<Options<ListPostsApiV1PostsGetData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListPostsApiV1PostsGetData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listPostsApiV1PostsGet({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listPostsApiV1PostsGetInfiniteQueryKey(options),
    }
  );

/**
 * Create a new post (V2: with scope/category)
 *
 * Create a new post. Requires authentication. Free users limited to 2 posts per day, Premium to 20.
 */
export const createPostApiV1PostsPostMutation = (
  options?: Partial<Options<CreatePostApiV1PostsPostData>>
): UseMutationOptions<
  CreatePostApiV1PostsPostResponse,
  DefaultError,
  Options<CreatePostApiV1PostsPostData>
> => {
  const mutationOptions: UseMutationOptions<
    CreatePostApiV1PostsPostResponse,
    DefaultError,
    Options<CreatePostApiV1PostsPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createPostApiV1PostsPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getPostApiV1PostsPostIdGetQueryKey = (
  options: Options<GetPostApiV1PostsPostIdGetData>
) => createQueryKey('getPostApiV1PostsPostIdGet', options);

/**
 * Get a single post by ID
 *
 * Retrieve a post by its ID. Phase 9: Includes media_asset_ids for image display.
 */
export const getPostApiV1PostsPostIdGetOptions = (
  options: Options<GetPostApiV1PostsPostIdGetData>
) =>
  queryOptions<
    GetPostApiV1PostsPostIdGetResponse,
    GetPostApiV1PostsPostIdGetError,
    GetPostApiV1PostsPostIdGetResponse,
    ReturnType<typeof getPostApiV1PostsPostIdGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPostApiV1PostsPostIdGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPostApiV1PostsPostIdGetQueryKey(options),
  });

/**
 * Close a post
 *
 * Manually close a post. Only post owner can close.
 */
export const closePostApiV1PostsPostIdClosePostMutation = (
  options?: Partial<Options<ClosePostApiV1PostsPostIdClosePostData>>
): UseMutationOptions<
  ClosePostApiV1PostsPostIdClosePostResponse,
  DefaultError,
  Options<ClosePostApiV1PostsPostIdClosePostData>
> => {
  const mutationOptions: UseMutationOptions<
    ClosePostApiV1PostsPostIdClosePostResponse,
    DefaultError,
    Options<ClosePostApiV1PostsPostIdClosePostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await closePostApiV1PostsPostIdClosePost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Toggle like on a post (FR-008, FR-009)
 *
 * Like or unlike a post. Idempotent: if already liked, unlikes; if not liked, likes. Each user can like a post at most once.
 */
export const toggleLikeApiV1PostsPostIdLikePostMutation = (
  options?: Partial<Options<ToggleLikeApiV1PostsPostIdLikePostData>>
): UseMutationOptions<
  ToggleLikeApiV1PostsPostIdLikePostResponse,
  ToggleLikeApiV1PostsPostIdLikePostError,
  Options<ToggleLikeApiV1PostsPostIdLikePostData>
> => {
  const mutationOptions: UseMutationOptions<
    ToggleLikeApiV1PostsPostIdLikePostResponse,
    ToggleLikeApiV1PostsPostIdLikePostError,
    Options<ToggleLikeApiV1PostsPostIdLikePostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await toggleLikeApiV1PostsPostIdLikePost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listPostCommentsApiV1PostsPostIdCommentsGetQueryKey = (
  options: Options<ListPostCommentsApiV1PostsPostIdCommentsGetData>
) => createQueryKey('listPostCommentsApiV1PostsPostIdCommentsGet', options);

/**
 * List comments on a post
 *
 * Returns list of comments for a post (latest first)
 */
export const listPostCommentsApiV1PostsPostIdCommentsGetOptions = (
  options: Options<ListPostCommentsApiV1PostsPostIdCommentsGetData>
) =>
  queryOptions<
    ListPostCommentsApiV1PostsPostIdCommentsGetResponse,
    ListPostCommentsApiV1PostsPostIdCommentsGetError,
    ListPostCommentsApiV1PostsPostIdCommentsGetResponse,
    ReturnType<typeof listPostCommentsApiV1PostsPostIdCommentsGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listPostCommentsApiV1PostsPostIdCommentsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listPostCommentsApiV1PostsPostIdCommentsGetQueryKey(options),
  });

export const listPostCommentsApiV1PostsPostIdCommentsGetInfiniteQueryKey = (
  options: Options<ListPostCommentsApiV1PostsPostIdCommentsGetData>
): QueryKey<Options<ListPostCommentsApiV1PostsPostIdCommentsGetData>> =>
  createQueryKey('listPostCommentsApiV1PostsPostIdCommentsGet', options, true);

/**
 * List comments on a post
 *
 * Returns list of comments for a post (latest first)
 */
export const listPostCommentsApiV1PostsPostIdCommentsGetInfiniteOptions = (
  options: Options<ListPostCommentsApiV1PostsPostIdCommentsGetData>
) =>
  infiniteQueryOptions<
    ListPostCommentsApiV1PostsPostIdCommentsGetResponse,
    ListPostCommentsApiV1PostsPostIdCommentsGetError,
    InfiniteData<ListPostCommentsApiV1PostsPostIdCommentsGetResponse>,
    QueryKey<Options<ListPostCommentsApiV1PostsPostIdCommentsGetData>>,
    | number
    | Pick<
        QueryKey<Options<ListPostCommentsApiV1PostsPostIdCommentsGetData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListPostCommentsApiV1PostsPostIdCommentsGetData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listPostCommentsApiV1PostsPostIdCommentsGet({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listPostCommentsApiV1PostsPostIdCommentsGetInfiniteQueryKey(options),
    }
  );

/**
 * Create a comment on a post
 *
 * Create a new comment on the specified post (requires authentication)
 */
export const createPostCommentApiV1PostsPostIdCommentsPostMutation = (
  options?: Partial<Options<CreatePostCommentApiV1PostsPostIdCommentsPostData>>
): UseMutationOptions<
  CreatePostCommentApiV1PostsPostIdCommentsPostResponse,
  CreatePostCommentApiV1PostsPostIdCommentsPostError,
  Options<CreatePostCommentApiV1PostsPostIdCommentsPostData>
> => {
  const mutationOptions: UseMutationOptions<
    CreatePostCommentApiV1PostsPostIdCommentsPostResponse,
    CreatePostCommentApiV1PostsPostIdCommentsPostError,
    Options<CreatePostCommentApiV1PostsPostIdCommentsPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createPostCommentApiV1PostsPostIdCommentsPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCitiesApiV1LocationsCitiesGetQueryKey = (
  options?: Options<GetCitiesApiV1LocationsCitiesGetData>
) => createQueryKey('getCitiesApiV1LocationsCitiesGet', options);

/**
 * Get all Taiwan cities
 *
 * Get a list of all available Taiwan cities/counties.
 *
 * This endpoint provides the complete list of Taiwan's 22 cities/counties including:
 * - **Six Special Municipalities** (Áõ¥ËΩÑÂ∏Ç): Taipei, New Taipei, Taoyuan, Taichung, Tainan, Kaohsiung
 * - **Provincial Cities** (ÁúÅËΩÑÂ∏Ç): Hsinchu City, Chiayi City
 * - **Counties** (Á∏£): Hsinchu County, Miaoli, Changhua, Nantou, Yunlin, Chiayi County, Pingtung, Yilan, Hualien, Taitung, Penghu, Kinmen, Lienchiang
 *
 * Each city includes:
 * - `code`: City code used in APIs (e.g., TPE, NTP, TAO)
 * - `name`: English name (e.g., Taipei City)
 * - `name_zh`: Chinese name (e.g., Âè∞ÂåóÂ∏Ç)
 *
 * This is a public endpoint that **does not require authentication**.
 * Frontend applications should use this to dynamically populate city selection dropdowns.
 */
export const getCitiesApiV1LocationsCitiesGetOptions = (
  options?: Options<GetCitiesApiV1LocationsCitiesGetData>
) =>
  queryOptions<
    GetCitiesApiV1LocationsCitiesGetResponse,
    DefaultError,
    GetCitiesApiV1LocationsCitiesGetResponse,
    ReturnType<typeof getCitiesApiV1LocationsCitiesGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCitiesApiV1LocationsCitiesGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCitiesApiV1LocationsCitiesGetQueryKey(options),
  });

export const getUserGalleryCardsApiV1UsersUserIdGalleryCardsGetQueryKey = (
  options: Options<GetUserGalleryCardsApiV1UsersUserIdGalleryCardsGetData>
) => createQueryKey('getUserGalleryCardsApiV1UsersUserIdGalleryCardsGet', options);

/**
 * Get user's gallery cards
 *
 * View another user's public gallery cards (requires authentication).
 */
export const getUserGalleryCardsApiV1UsersUserIdGalleryCardsGetOptions = (
  options: Options<GetUserGalleryCardsApiV1UsersUserIdGalleryCardsGetData>
) =>
  queryOptions<
    GetUserGalleryCardsApiV1UsersUserIdGalleryCardsGetResponse,
    GetUserGalleryCardsApiV1UsersUserIdGalleryCardsGetError,
    GetUserGalleryCardsApiV1UsersUserIdGalleryCardsGetResponse,
    ReturnType<typeof getUserGalleryCardsApiV1UsersUserIdGalleryCardsGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserGalleryCardsApiV1UsersUserIdGalleryCardsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserGalleryCardsApiV1UsersUserIdGalleryCardsGetQueryKey(options),
  });

export const getMyGalleryCardsApiV1GalleryCardsMeGetQueryKey = (
  options?: Options<GetMyGalleryCardsApiV1GalleryCardsMeGetData>
) => createQueryKey('getMyGalleryCardsApiV1GalleryCardsMeGet', options);

/**
 * Get my gallery cards
 *
 * Get the authenticated user's own gallery cards.
 */
export const getMyGalleryCardsApiV1GalleryCardsMeGetOptions = (
  options?: Options<GetMyGalleryCardsApiV1GalleryCardsMeGetData>
) =>
  queryOptions<
    GetMyGalleryCardsApiV1GalleryCardsMeGetResponse,
    GetMyGalleryCardsApiV1GalleryCardsMeGetError,
    GetMyGalleryCardsApiV1GalleryCardsMeGetResponse,
    ReturnType<typeof getMyGalleryCardsApiV1GalleryCardsMeGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMyGalleryCardsApiV1GalleryCardsMeGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMyGalleryCardsApiV1GalleryCardsMeGetQueryKey(options),
  });

/**
 * Create gallery card
 *
 * Create a new gallery card in the user's personal album.
 */
export const createGalleryCardApiV1GalleryCardsPostMutation = (
  options?: Partial<Options<CreateGalleryCardApiV1GalleryCardsPostData>>
): UseMutationOptions<
  CreateGalleryCardApiV1GalleryCardsPostResponse,
  CreateGalleryCardApiV1GalleryCardsPostError,
  Options<CreateGalleryCardApiV1GalleryCardsPostData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateGalleryCardApiV1GalleryCardsPostResponse,
    CreateGalleryCardApiV1GalleryCardsPostError,
    Options<CreateGalleryCardApiV1GalleryCardsPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createGalleryCardApiV1GalleryCardsPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete gallery card
 *
 * Delete a gallery card (only owner can delete).
 */
export const deleteGalleryCardApiV1GalleryCardsCardIdDeleteMutation = (
  options?: Partial<Options<DeleteGalleryCardApiV1GalleryCardsCardIdDeleteData>>
): UseMutationOptions<
  DeleteGalleryCardApiV1GalleryCardsCardIdDeleteResponse,
  DeleteGalleryCardApiV1GalleryCardsCardIdDeleteError,
  Options<DeleteGalleryCardApiV1GalleryCardsCardIdDeleteData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteGalleryCardApiV1GalleryCardsCardIdDeleteResponse,
    DeleteGalleryCardApiV1GalleryCardsCardIdDeleteError,
    Options<DeleteGalleryCardApiV1GalleryCardsCardIdDeleteData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteGalleryCardApiV1GalleryCardsCardIdDelete({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Reorder gallery cards
 *
 * Update the display order of gallery cards.
 */
export const reorderGalleryCardsApiV1GalleryCardsReorderPutMutation = (
  options?: Partial<Options<ReorderGalleryCardsApiV1GalleryCardsReorderPutData>>
): UseMutationOptions<
  ReorderGalleryCardsApiV1GalleryCardsReorderPutResponse,
  ReorderGalleryCardsApiV1GalleryCardsReorderPutError,
  Options<ReorderGalleryCardsApiV1GalleryCardsReorderPutData>
> => {
  const mutationOptions: UseMutationOptions<
    ReorderGalleryCardsApiV1GalleryCardsReorderPutResponse,
    ReorderGalleryCardsApiV1GalleryCardsReorderPutError,
    Options<ReorderGalleryCardsApiV1GalleryCardsReorderPutData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await reorderGalleryCardsApiV1GalleryCardsReorderPut({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Generate presigned upload URL
 *
 * Step 1: Generate a presigned URL for uploading media to GCS. FR-006.
 */
export const createUploadUrlApiV1MediaUploadUrlPostMutation = (
  options?: Partial<Options<CreateUploadUrlApiV1MediaUploadUrlPostData>>
): UseMutationOptions<
  CreateUploadUrlApiV1MediaUploadUrlPostResponse,
  CreateUploadUrlApiV1MediaUploadUrlPostError,
  Options<CreateUploadUrlApiV1MediaUploadUrlPostData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateUploadUrlApiV1MediaUploadUrlPostResponse,
    CreateUploadUrlApiV1MediaUploadUrlPostError,
    Options<CreateUploadUrlApiV1MediaUploadUrlPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createUploadUrlApiV1MediaUploadUrlPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Confirm media upload
 *
 * Step 2: Confirm that media was uploaded to GCS. Applies quota. FR-022, T052.
 */
export const confirmUploadApiV1MediaMediaIdConfirmPostMutation = (
  options?: Partial<Options<ConfirmUploadApiV1MediaMediaIdConfirmPostData>>
): UseMutationOptions<
  ConfirmUploadApiV1MediaMediaIdConfirmPostResponse,
  ConfirmUploadApiV1MediaMediaIdConfirmPostError,
  Options<ConfirmUploadApiV1MediaMediaIdConfirmPostData>
> => {
  const mutationOptions: UseMutationOptions<
    ConfirmUploadApiV1MediaMediaIdConfirmPostResponse,
    ConfirmUploadApiV1MediaMediaIdConfirmPostError,
    Options<ConfirmUploadApiV1MediaMediaIdConfirmPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await confirmUploadApiV1MediaMediaIdConfirmPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Attach media to post
 *
 * Step 3: Attach confirmed media to a post. FR-007.
 */
export const attachMediaToPostApiV1MediaPostsPostIdAttachPostMutation = (
  options?: Partial<Options<AttachMediaToPostApiV1MediaPostsPostIdAttachPostData>>
): UseMutationOptions<
  AttachMediaToPostApiV1MediaPostsPostIdAttachPostResponse,
  AttachMediaToPostApiV1MediaPostsPostIdAttachPostError,
  Options<AttachMediaToPostApiV1MediaPostsPostIdAttachPostData>
> => {
  const mutationOptions: UseMutationOptions<
    AttachMediaToPostApiV1MediaPostsPostIdAttachPostResponse,
    AttachMediaToPostApiV1MediaPostsPostIdAttachPostError,
    Options<AttachMediaToPostApiV1MediaPostsPostIdAttachPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await attachMediaToPostApiV1MediaPostsPostIdAttachPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Attach media to gallery card
 *
 * Step 3: Attach confirmed media to a gallery card. FR-007, FR-020.
 */
export const attachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostMutation = (
  options?: Partial<Options<AttachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostData>>
): UseMutationOptions<
  AttachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostResponse,
  AttachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostError,
  Options<AttachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostData>
> => {
  const mutationOptions: UseMutationOptions<
    AttachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostResponse,
    AttachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostError,
    Options<AttachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await attachMediaToGalleryCardApiV1MediaGalleryCardsCardIdAttachPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Get signed read URLs for media assets (Phase 9)
 *
 * Batch retrieve signed download URLs for media. Login required. T083-T085.
 */
export const getMediaReadUrlsApiV1MediaReadUrlsPostMutation = (
  options?: Partial<Options<GetMediaReadUrlsApiV1MediaReadUrlsPostData>>
): UseMutationOptions<
  GetMediaReadUrlsApiV1MediaReadUrlsPostResponse,
  GetMediaReadUrlsApiV1MediaReadUrlsPostError,
  Options<GetMediaReadUrlsApiV1MediaReadUrlsPostData>
> => {
  const mutationOptions: UseMutationOptions<
    GetMediaReadUrlsApiV1MediaReadUrlsPostResponse,
    GetMediaReadUrlsApiV1MediaReadUrlsPostError,
    Options<GetMediaReadUrlsApiV1MediaReadUrlsPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await getMediaReadUrlsApiV1MediaReadUrlsPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Create Message Request
 *
 * Create a message request to another user.
 *
 * Implements FR-011: Message Requests for strangers.
 * Implements FR-013: Privacy setting to block stranger messages.
 * Implements FR-014: One unique thread per user pair.
 */
export const createMessageRequestApiV1MessageRequestsPostMutation = (
  options?: Partial<Options<CreateMessageRequestApiV1MessageRequestsPostData>>
): UseMutationOptions<
  CreateMessageRequestApiV1MessageRequestsPostResponse,
  CreateMessageRequestApiV1MessageRequestsPostError,
  Options<CreateMessageRequestApiV1MessageRequestsPostData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateMessageRequestApiV1MessageRequestsPostResponse,
    CreateMessageRequestApiV1MessageRequestsPostError,
    Options<CreateMessageRequestApiV1MessageRequestsPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createMessageRequestApiV1MessageRequestsPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getMyMessageRequestsApiV1MessageRequestsInboxGetQueryKey = (
  options?: Options<GetMyMessageRequestsApiV1MessageRequestsInboxGetData>
) => createQueryKey('getMyMessageRequestsApiV1MessageRequestsInboxGet', options);

/**
 * Get My Message Requests
 *
 * Get message requests for the current user.
 *
 * Supports FR-016: Inbox clearly separates Requests vs Threads.
 *
 * Query params:
 * - status_filter: "pending", "accepted", "declined", or "all" (default: "pending")
 */
export const getMyMessageRequestsApiV1MessageRequestsInboxGetOptions = (
  options?: Options<GetMyMessageRequestsApiV1MessageRequestsInboxGetData>
) =>
  queryOptions<
    GetMyMessageRequestsApiV1MessageRequestsInboxGetResponse,
    GetMyMessageRequestsApiV1MessageRequestsInboxGetError,
    GetMyMessageRequestsApiV1MessageRequestsInboxGetResponse,
    ReturnType<typeof getMyMessageRequestsApiV1MessageRequestsInboxGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMyMessageRequestsApiV1MessageRequestsInboxGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMyMessageRequestsApiV1MessageRequestsInboxGetQueryKey(options),
  });

export const getMySentMessageRequestsApiV1MessageRequestsSentGetQueryKey = (
  options?: Options<GetMySentMessageRequestsApiV1MessageRequestsSentGetData>
) => createQueryKey('getMySentMessageRequestsApiV1MessageRequestsSentGet', options);

/**
 * Get My Sent Message Requests
 *
 * Get message requests sent by the current user.
 *
 * Sender typically only needs pending status.
 *
 * Query params:
 * - status_filter: "pending", "accepted", "declined", or "all" (default: "pending")
 */
export const getMySentMessageRequestsApiV1MessageRequestsSentGetOptions = (
  options?: Options<GetMySentMessageRequestsApiV1MessageRequestsSentGetData>
) =>
  queryOptions<
    GetMySentMessageRequestsApiV1MessageRequestsSentGetResponse,
    GetMySentMessageRequestsApiV1MessageRequestsSentGetError,
    GetMySentMessageRequestsApiV1MessageRequestsSentGetResponse,
    ReturnType<typeof getMySentMessageRequestsApiV1MessageRequestsSentGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMySentMessageRequestsApiV1MessageRequestsSentGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMySentMessageRequestsApiV1MessageRequestsSentGetQueryKey(options),
  });

/**
 * Accept Message Request
 *
 * Accept a message request and create a thread.
 *
 * Implements FR-012: Recipient can accept/decline requests.
 * Creates unique thread (FR-014).
 */
export const acceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostMutation = (
  options?: Partial<Options<AcceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostData>>
): UseMutationOptions<
  AcceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostResponse,
  AcceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostError,
  Options<AcceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostData>
> => {
  const mutationOptions: UseMutationOptions<
    AcceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostResponse,
    AcceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostError,
    Options<AcceptMessageRequestApiV1MessageRequestsRequestIdAcceptPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await acceptMessageRequestApiV1MessageRequestsRequestIdAcceptPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Decline Message Request
 *
 * Decline a message request.
 *
 * Implements FR-012: Recipient can accept/decline requests.
 */
export const declineMessageRequestApiV1MessageRequestsRequestIdDeclinePostMutation = (
  options?: Partial<Options<DeclineMessageRequestApiV1MessageRequestsRequestIdDeclinePostData>>
): UseMutationOptions<
  DeclineMessageRequestApiV1MessageRequestsRequestIdDeclinePostResponse,
  DeclineMessageRequestApiV1MessageRequestsRequestIdDeclinePostError,
  Options<DeclineMessageRequestApiV1MessageRequestsRequestIdDeclinePostData>
> => {
  const mutationOptions: UseMutationOptions<
    DeclineMessageRequestApiV1MessageRequestsRequestIdDeclinePostResponse,
    DeclineMessageRequestApiV1MessageRequestsRequestIdDeclinePostError,
    Options<DeclineMessageRequestApiV1MessageRequestsRequestIdDeclinePostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await declineMessageRequestApiV1MessageRequestsRequestIdDeclinePost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getMyThreadsApiV1ThreadsGetQueryKey = (
  options?: Options<GetMyThreadsApiV1ThreadsGetData>
) => createQueryKey('getMyThreadsApiV1ThreadsGet', options);

/**
 * Get My Threads
 *
 * Get all threads for the current user.
 *
 * Supports FR-016: Inbox clearly separates Requests vs Threads.
 * Returns threads ordered by last_message_at descending.
 */
export const getMyThreadsApiV1ThreadsGetOptions = (
  options?: Options<GetMyThreadsApiV1ThreadsGetData>
) =>
  queryOptions<
    GetMyThreadsApiV1ThreadsGetResponse,
    GetMyThreadsApiV1ThreadsGetError,
    GetMyThreadsApiV1ThreadsGetResponse,
    ReturnType<typeof getMyThreadsApiV1ThreadsGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMyThreadsApiV1ThreadsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMyThreadsApiV1ThreadsGetQueryKey(options),
  });

export const getMyThreadsApiV1ThreadsGetInfiniteQueryKey = (
  options?: Options<GetMyThreadsApiV1ThreadsGetData>
): QueryKey<Options<GetMyThreadsApiV1ThreadsGetData>> =>
  createQueryKey('getMyThreadsApiV1ThreadsGet', options, true);

/**
 * Get My Threads
 *
 * Get all threads for the current user.
 *
 * Supports FR-016: Inbox clearly separates Requests vs Threads.
 * Returns threads ordered by last_message_at descending.
 */
export const getMyThreadsApiV1ThreadsGetInfiniteOptions = (
  options?: Options<GetMyThreadsApiV1ThreadsGetData>
) =>
  infiniteQueryOptions<
    GetMyThreadsApiV1ThreadsGetResponse,
    GetMyThreadsApiV1ThreadsGetError,
    InfiniteData<GetMyThreadsApiV1ThreadsGetResponse>,
    QueryKey<Options<GetMyThreadsApiV1ThreadsGetData>>,
    | number
    | Pick<
        QueryKey<Options<GetMyThreadsApiV1ThreadsGetData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetMyThreadsApiV1ThreadsGetData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getMyThreadsApiV1ThreadsGet({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getMyThreadsApiV1ThreadsGetInfiniteQueryKey(options),
    }
  );

export const getThreadMessagesApiV1ThreadsThreadIdMessagesGetQueryKey = (
  options: Options<GetThreadMessagesApiV1ThreadsThreadIdMessagesGetData>
) => createQueryKey('getThreadMessagesApiV1ThreadsThreadIdMessagesGet', options);

/**
 * Get Thread Messages
 *
 * Get messages in a thread.
 *
 * Returns messages ordered by created_at ascending (oldest first).
 * User must be part of the thread to view messages.
 */
export const getThreadMessagesApiV1ThreadsThreadIdMessagesGetOptions = (
  options: Options<GetThreadMessagesApiV1ThreadsThreadIdMessagesGetData>
) =>
  queryOptions<
    GetThreadMessagesApiV1ThreadsThreadIdMessagesGetResponse,
    GetThreadMessagesApiV1ThreadsThreadIdMessagesGetError,
    GetThreadMessagesApiV1ThreadsThreadIdMessagesGetResponse,
    ReturnType<typeof getThreadMessagesApiV1ThreadsThreadIdMessagesGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getThreadMessagesApiV1ThreadsThreadIdMessagesGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getThreadMessagesApiV1ThreadsThreadIdMessagesGetQueryKey(options),
  });

export const getThreadMessagesApiV1ThreadsThreadIdMessagesGetInfiniteQueryKey = (
  options: Options<GetThreadMessagesApiV1ThreadsThreadIdMessagesGetData>
): QueryKey<Options<GetThreadMessagesApiV1ThreadsThreadIdMessagesGetData>> =>
  createQueryKey('getThreadMessagesApiV1ThreadsThreadIdMessagesGet', options, true);

/**
 * Get Thread Messages
 *
 * Get messages in a thread.
 *
 * Returns messages ordered by created_at ascending (oldest first).
 * User must be part of the thread to view messages.
 */
export const getThreadMessagesApiV1ThreadsThreadIdMessagesGetInfiniteOptions = (
  options: Options<GetThreadMessagesApiV1ThreadsThreadIdMessagesGetData>
) =>
  infiniteQueryOptions<
    GetThreadMessagesApiV1ThreadsThreadIdMessagesGetResponse,
    GetThreadMessagesApiV1ThreadsThreadIdMessagesGetError,
    InfiniteData<GetThreadMessagesApiV1ThreadsThreadIdMessagesGetResponse>,
    QueryKey<Options<GetThreadMessagesApiV1ThreadsThreadIdMessagesGetData>>,
    | number
    | Pick<
        QueryKey<Options<GetThreadMessagesApiV1ThreadsThreadIdMessagesGetData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetThreadMessagesApiV1ThreadsThreadIdMessagesGetData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getThreadMessagesApiV1ThreadsThreadIdMessagesGet({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getThreadMessagesApiV1ThreadsThreadIdMessagesGetInfiniteQueryKey(options),
    }
  );

/**
 * Send Message
 *
 * Send a message in a thread.
 *
 * Supports FR-015: Messages can reference post_id.
 * User must be part of the thread to send messages.
 */
export const sendMessageApiV1ThreadsThreadIdMessagesPostMutation = (
  options?: Partial<Options<SendMessageApiV1ThreadsThreadIdMessagesPostData>>
): UseMutationOptions<
  SendMessageApiV1ThreadsThreadIdMessagesPostResponse,
  SendMessageApiV1ThreadsThreadIdMessagesPostError,
  Options<SendMessageApiV1ThreadsThreadIdMessagesPostData>
> => {
  const mutationOptions: UseMutationOptions<
    SendMessageApiV1ThreadsThreadIdMessagesPostResponse,
    SendMessageApiV1ThreadsThreadIdMessagesPostError,
    Options<SendMessageApiV1ThreadsThreadIdMessagesPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await sendMessageApiV1ThreadsThreadIdMessagesPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};
